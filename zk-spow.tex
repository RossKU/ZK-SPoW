\documentclass[11pt,a4paper]{article}

% --- Packages ---
\usepackage[margin=1in]{geometry}
\usepackage{amsmath,amssymb,amsthm}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{array}
\usepackage{graphicx}
\usepackage{fancyvrb}
\usepackage[breaklinks=true]{hyperref}
\usepackage{url}
\urlstyle{same}
\usepackage{microtype}
\usepackage{parskip}

% --- Theorem environments ---
\newtheorem{definition}{Definition}
\newtheorem{proposition}{Proposition}

% --- Title ---
\title{\textbf{ZK-SPoW: ZK-Symbiotic Proof of Work for Kaspa}}
\author{Anonymous\thanks{Preprint. Work in progress.}}
\date{February 2026 --- Version 0.3 (Draft)}

\begin{document}
\maketitle

% ============================================================
\begin{abstract}
We propose replacing Kaspa's kHeavyHash proof-of-work function with a Width-24 Poseidon2 compression function over the Mersenne field $\mathbb{F}_p$, $p = 2^{31}-1$ (M31). Traditional Proof of Useful Work (PoUW) attempts to make PoW computation produce useful results---a direction that Ball et al.~\cite{ball2017} show requires careful construction with practical deployment constraints. ZK-SPoW (ZK-Symbiotic Proof of Work) inverts this relationship: useful ZK computation (STARK Merkle hashing) naturally produces PoW tickets as a mathematical byproduct. By operating Poseidon2 in compression function mode with width~24, every STARK Merkle hash accepts a child pair plus block header digest as input and simultaneously outputs a parent node advancing the ZK proof and three PoW tickets---from a single permutation. The miner does not choose the PoW input; the STARK computation determines it. This unification carries a cost of $U = t_0/t = 16/24 \approx 67\%$---the remaining 33\% of each permutation serves PoW integration. In return, the same hardware performs both network security and useful computation with zero switching overhead. Width-24 requires a Kaspa-specific STARK verifier supporting Width-24 Poseidon2 compression---a parameter change within the Poseidon2 framework, and an incremental cost within the kHeavyHash $\to$ Poseidon2 hard fork. Security claims assume final Poseidon2 production parameters (\S\ref{sec:open}).
\end{abstract}

% ============================================================
\section{Introduction}
\label{sec:intro}

\subsection{The PoW Energy Problem}

Kaspa uses kHeavyHash---cSHAKE256 (Keccak/SHA-3 family) composed with a $64\times64$ matrix multiplication over 4-bit nibbles---for proof of work. Like all traditional PoW schemes, the computational work produces no output beyond network security. The entire energy expenditure is justified solely by the security guarantees it provides.

\subsection{The PoUW Paradox and Its Inversion}
\label{sec:pouw-paradox}

Ball et al.~\cite{ball2017} formalize \textbf{Proof of Useful Work (PoUW)} as a PoW scheme where the mining computation simultaneously produces useful output. Their strict definition requires:
\begin{enumerate}
\item The PoW computation itself produces useful output
\item The verifier can confirm the usefulness
\item The useful output is bound to the PoW evidence
\end{enumerate}

The fundamental tension: PoW requires random exploration (nonce grinding), while useful computation requires specific, deterministic work. Prior PoUW constructions \cite{ball2017,ofelimos,komargodski2025,baron2025} achieve provable security for specific problem classes, but require pre-hashing, SNARGs, or domain-specific verification that limits practical deployment in high-throughput blockchains (100~BPS).

\textbf{ZK-SPoW inverts this relationship.} Instead of making PoW results useful, we start from useful computation (STARK proof generation) and observe that PoW tickets emerge as a natural mathematical byproduct:

\begin{quote}
\textbf{Conventional PoUW:} PoW computation $\to$ try to make results useful $\to$ fundamental constraints~\cite{ball2017}

\textbf{ZK-SPoW:} Useful ZK computation $\to$ PoW tickets as mathematical byproduct $\to$ no contradiction
\end{quote}

\begin{definition}[ZK-SPoW]
A PoW scheme where the hash function is a width-extended Poseidon2 compression function operating on STARK Merkle data, such that every permutation simultaneously advances a ZK proof and produces PoW tickets.
\end{definition}

The mechanism: STARK proof generation requires millions of Merkle hashes. Each Width-24 Poseidon2 Merkle hash takes $(\mathit{left\_child}, \mathit{right\_child}, \mathit{header\_digest})$ as input and produces $(\mathit{pow\_ticket}_0, \mathit{pow\_ticket}_1, \mathit{pow\_ticket}_2)$ as output, where $\mathit{pow\_ticket}_0 = \mathit{merkle\_parent}$ simultaneously advances the ZK proof. All three output regions are checked against the difficulty target. The miner cannot choose the Merkle inputs---they are determined by the STARK computation. The ``random exploration'' required for PoW occurs naturally because STARK Merkle tree hashes are pseudorandom from the miner's perspective.

\begin{definition}[Usefulness]
\begin{itemize}
\item $U = t_0/t = 16/24 \approx 67\%$ when the ASIC is executing ZK proof computation (Symbiotic mode)
\item $U = 0\%$ when the ASIC is grinding nonces without concurrent ZK computation (Pure PoW mode)
\end{itemize}
The 33\% overhead per permutation is the cost of PoW integration: 8 of 24 input state elements carry $\mathit{header\_digest}$ rather than ZK data. This is the inherent price of unifying ZK and PoW into a single permutation---not waste, but the cost of symbiosis. On the output side, all three 8-element regions serve as PoW tickets, and $S[0..7]$ simultaneously advances the ZK proof---the purest form of symbiosis.

$U$ is a per-permutation metric. The time-averaged usefulness across all Poseidon2 cycles is $U_{\mathrm{avg}} = f_{\mathrm{sym}} \times U$, where $f_{\mathrm{sym}}$ is the fraction of cycles executing STARK Merkle hashes (determined by memory bandwidth; see \S\ref{sec:bottleneck} and \S\ref{sec:sram}).
\end{definition}

If a PoW solution is found mid-proof, the block is submitted without interrupting ZK computation. When no ZK demand exists, the ASIC reverts to pure PoW ($U = 0\%$), identical to any conventional miner.

\subsection{Stwo and Poseidon2}

Kaspa is evaluating StarkWare's \textbf{Stwo}~\cite{stwo} as a potential STARK backend for verifiable programs (vProgs). Stwo operates over the Mersenne field M31 and uses \textbf{Poseidon2}~\cite{poseidon2} as its internal hash function for Merkle tree commitments and Fiat-Shamir challenges.

This creates a unique opportunity: if the PoW hash function is also Poseidon2 over M31, then the mining ASIC's primary computational element---the Poseidon2 pipeline---can serve both STARK proof generation and PoW mining. The cost is a Poseidon2 width extension from 16 to 24 elements with increased round count ($+44$--$105\%$ core area, ${\sim}+22$--$50\%$ die area depending on implementation; see \S\ref{sec:width}).

\textbf{Stwo-Kaspa verifier.} Standard Stwo uses Width-16 Poseidon2 in sponge mode. Width-24 Poseidon2 is a different cryptographic function (different MDS matrix, different round count, different S-box count per external round). ZK-SPoW therefore requires a Kaspa-specific verifier supporting Width-24 compression---a parameter change within Poseidon2's design framework~\cite{poseidon2}, not a new cryptographic construction. Since the kHeavyHash $\to$ Poseidon2 transition already requires a hard fork with full-node verifier updates, the Width-24 adaptation is an incremental cost.

\subsection{Contributions}
\label{sec:contributions}

\begin{enumerate}
\item \textbf{PoUW paradox inversion.} We formalize ZK-Symbiotic Proof of Work, a construction where useful ZK computation (STARK Merkle hashing) naturally produces PoW tickets as a cryptographically bound byproduct---inverting the traditional PoUW direction explored by Ball et al.~\cite{ball2017}, Ofelimos~\cite{ofelimos}, and Komargodski et al.~\cite{komargodski2025,baron2025} (\S\ref{sec:pouw-paradox}).

\item \textbf{Width-24 Poseidon2 parameterization.} We specify Width-24 Poseidon2 over M31 in compression function mode and verify its security parameters: $R_p = 22$ internal rounds for 128-bit security with $D = 5$, confirmed via Plonky3's verified round number computation~\cite{plonky3}. The per-ticket S-box cost decreases by 50\% compared to Width-16 despite 51\% more S-box operations per permutation, due to the triple-ticket structure (\S\ref{sec:width24sec}).

\item \textbf{Complementary bottleneck architecture.} We demonstrate that PoW mining (compute-bound) and STARK proof generation (memory-bound) can share Poseidon2 hardware with zero-cycle switching overhead, and provide gate-level ASIC architecture analysis for a 7\,nm implementation (\S\ref{sec:modes}, Appendix~\ref{app:asic}).
\end{enumerate}

% ============================================================
\section{Notation and Definitions}
\label{sec:notation}

\begin{table}[h]
\centering
\begin{tabular}{@{}ll@{}}
\toprule
Symbol & Definition \\
\midrule
$\mathbb{F}_p$ & Finite field, $p = 2^{31}-1$ (Mersenne prime M31) \\
$\mathrm{Poseidon2}_\pi$ & Poseidon2 permutation over $\mathbb{F}_p^t$ \\
$t$ & State width (number of field elements in permutation) \\
$r$ & Rate: number of input/output elements (sponge mode) \\
$c$ & Capacity: security parameter (sponge mode; hidden elements) \\
$n$ & Hash output size in field elements ($n = 8$, giving 248 bits) \\
$H$ & Block header (all consensus fields; see \S\ref{sec:block}) \\
$h_H$ & Header digest: $\mathrm{PoseidonSponge}(H \text{ excluding nonce}) \in \mathbb{F}_p^k$ \\
$k$ & Header digest element count ($k = 8$ for symmetric I/O and three PoW tickets) \\
$(v_1, v_2)$ & Nonce: $v_1, v_2 \in \mathbb{F}_p^8$ \\
$T$ & Target $\in \mathbb{F}_p^8$ (difficulty-adjusted) \\
$S$ & Poseidon2 state after permutation, $S \in \mathbb{F}_p^t$ \\
\bottomrule
\end{tabular}
\caption{Notation summary.}
\label{tab:notation}
\end{table}

\textbf{Stwo baseline parameters} (confirmed from source code~\cite{stwo}):

\begin{table}[h]
\centering
\begin{tabular}{@{}ll@{}}
\toprule
Parameter & Value \\
\midrule
Field & M31, $p = 2^{31}-1$ \\
Hash output & 8 elements = 248 bits \\
Standard width & $t_0 = 16$ (sponge mode: rate 8, capacity 8) \\
External rounds $R_f$ & 8 (4 + 4) \\
Internal rounds $R_p$ & 14 \\
S-box exponent & $\alpha = 5$ \\
Merkle hash & 2 permutations per node (sponge: absorb left[8], absorb right[8]) \\
Commitment hash & Blake2s (base layer), Poseidon2 (recursive proofs) \\
\bottomrule
\end{tabular}
\caption{Stwo baseline Poseidon2 parameters.}
\label{tab:stwo-baseline}
\end{table}

\textbf{Note:} All security claims in this paper assume final production round constants. The current Stwo implementation uses placeholder values (\texttt{EXTERNAL\_ROUND\_CONSTS} and \texttt{INTERNAL\_ROUND\_CONSTS} uniformly set to \texttt{1234}; see \S\ref{sec:open}).

% ============================================================
\section{Protocol Specification}
\label{sec:protocol}

\subsection{PoW Function Replacement}
\label{sec:pow-replacement}

\textbf{Current (kHeavyHash):}
\begin{Verbatim}[fontsize=\small]
pre_pow_hash = Blake2b(H excluding nonce and timestamp)
inner        = cSHAKE256_PoW(pre_pow_hash || timestamp || nonce)
pow_hash     = cSHAKE256_Heavy(M * inner XOR inner)
valid iff pow_hash < target
\end{Verbatim}
where $M$ is a $64\times64$ full-rank matrix over 4-bit nibbles (generated from \texttt{pre\_pow\_hash} via XoShiRo256++), nonce is 8~bytes (\texttt{u64}). The inner hash splits into 64~nibbles for matrix-vector multiplication; \texttt{cSHAKE256\_PoW} and \texttt{cSHAKE256\_Heavy} use domain strings \texttt{"ProofOfWorkHash"} and \texttt{"HeavyHash"} respectively~\cite{kaspa}.

\textbf{Proposed (Poseidon2-PoW):}
\begin{Verbatim}[fontsize=\small]
h_H = PoseidonSponge(H excluding nonce)       // amortized pre-hash (8 M31 elements)
S   = Poseidon2_pi(v1 || v2 || h_H)           // single permutation, width 24
pow_hash0 = (S[0], S[1], ..., S[7])            // 8 M31 elements = 248 bits
pow_hash1 = (S[8], S[9], ..., S[15])           // 8 M31 elements = 248 bits
pow_hash2 = (S[16], S[17], ..., S[23])         // 8 M31 elements = 248 bits
valid iff pow_hash0 < target OR pow_hash1 < target OR pow_hash2 < target
\end{Verbatim}
where $(v_1, v_2)$ are 8 M31 elements each (64 bytes total nonce). The permutation operates in \textbf{compression function mode}---all 24 input elements are visible (no hidden capacity). This differs from Stwo's standard sponge mode (width 16, rate 8, capacity 8) but is a recommended Poseidon2 usage mode~\cite{poseidon2}. Each permutation produces \textbf{three PoW tickets}---one from each 8-element output region. The comparison $\mathit{pow\_hash} < \mathit{target}$ interprets both as 248-bit unsigned integers via big-endian concatenation of 8 M31 elements, each zero-padded to 31 bits. In Symbiotic mode, $\mathit{pow\_hash}_0 = \mathit{merkle\_parent}$: the same output advances the ZK proof and serves as a PoW ticket (reading the value does not modify it).

\textbf{Verification cost:} One Poseidon2 permutation (width 24) + three target comparisons + one header pre-hash (amortized).

\textbf{Standard PoW structure.} ZK-SPoW is conventional hash-based PoW: miners explore a nonce space by computing Poseidon2 permutations and comparing outputs against a difficulty target, identically to Nakamoto-style PoW. The ZK component (Symbiotic mode, \S\ref{sec:symbiotic}) is an optional revenue source sharing the same hardware---it does not modify the PoW function, security model, or difficulty adjustment. When no ZK demand exists, the ASIC reverts to conventional PoW mining (\S\ref{sec:pure-pow}) with identical security guarantees.

\subsection{Poseidon2 Width Extension}
\label{sec:width}

The core design change is extending the Poseidon2 permutation width to accommodate header digest as an additional input, and switching from sponge mode to compression function mode.

\subsubsection{Stwo Baseline}

Stwo's Poseidon2 operates in \textbf{sponge mode} with width 16:
\begin{Verbatim}[fontsize=\small]
Width t0 = 16
Rate  r  = 8    <- absorbs 8 elements per permutation
Capacity c = 8  <- hidden elements (security)
\end{Verbatim}

For Merkle tree commitments, each node hash requires \textbf{two sponge absorptions}:
\begin{Verbatim}[fontsize=\small]
Absorb left_child[8]  -> Permute -> (state updated)
Absorb right_child[8] -> Permute -> Squeeze output[8]
Total: 2 permutations per Merkle hash
\end{Verbatim}

\subsubsection{Design Alternatives}
\label{sec:design-alt}

Three approaches to integrate header digest into the Merkle hash:

\begin{table}[h]
\centering
\small
\begin{tabular}{@{}lllcccc@{}}
\toprule
Design & Width & Mode & Perm/hash & PoW tickets & Core $\Delta$ & Die $\Delta$ \\
\midrule
A: 3rd absorb & 16 & Sponge & 3 (+50\%) & 1 & 0\% & 0\% \\
B: Width 20 & 20 & Compression & 1 & 1 (+4 wasted) & +22\% & ${\sim}$+11\% \\
\textbf{C: Width 24} & \textbf{24} & \textbf{Compression} & \textbf{1} & \textbf{3} & \textbf{+44--105\%} & $\mathbf{{\sim}\text{+22--50\%}}$ \\
\bottomrule
\end{tabular}
\caption{Design alternatives for header digest integration.}
\label{tab:designs}
\end{table}

\textbf{Design~A:} No Poseidon2 modification. Standard width-16 sponge with 3~absorptions (left, right, header). 3~permutations per Merkle hash; ZK throughput is unaffected under SRAM-bandwidth-bound operation (\S\ref{sec:bottleneck}).

\textbf{Design~B:} Extend to width~20 with $\mathit{header\_digest}[4]$. Compression function mode, 1~permutation per hash. But 4~output elements are unused (asymmetric $8{+}8{+}4$ I/O).

\textbf{Design~C (selected):} Extend to width~24 with $\mathit{header\_digest}[8]$. Symmetric $8{+}8{+}8$ I/O---all output elements are useful. \textbf{3~PoW tickets per permutation} ($S[0..7]$, $S[8..15]$, and $S[16..23]$; $S[0..7]$ doubles as $\mathit{merkle\_parent}$ in Symbiotic mode). Header digest security doubles (248 vs 124 bits). Width~24 is within the Poseidon2 paper's analyzed parameter range~\cite{poseidon2}. \textbf{ZK throughput is unaffected}: STARK Merkle hashing is SRAM-bandwidth-bound regardless of core width (see \S\ref{sec:bottleneck}). The width extension cost manifests as $U = 16/24 \approx 67\%$ (\S\ref{sec:pouw-paradox}). \textbf{Requires Stwo-Kaspa verifier} supporting Width-24 compression function mode.

\textbf{Design~A vs~C tradeoff.} Under current SRAM bandwidth (${\sim}200$~GB/s; \S\ref{sec:sram}), Design~A's smaller Width-16 cores yield more cores per die and higher total PoW hashrate despite 3~perm/hash. However, Design~A's $3\times$ permutation cost per STARK hash becomes a bottleneck as memory bandwidth increases: at HBM-class bandwidth ($>1$~TB/s), STARK saturates Design~A's Poseidon2 capacity, leaving minimal room for PoW. Design~C's 1~perm/hash scales linearly with bandwidth, maintaining full PoW throughput at any memory tier. Design~C also simplifies scheduling (each permutation is stateless, vs sponge state tracking across 3~absorptions in Design~A). The tradeoff: Design~A uses well-analyzed Width-16 parameters with no Stwo modification; Design~C requires a Width-24 Stwo-Kaspa verifier (\S\ref{sec:open}) but is future-proof for higher-bandwidth memory architectures.

\subsubsection{Proposed Extension (Design~C)}
\label{sec:design-c}

\begin{Verbatim}[fontsize=\small]
Standard Stwo:    Width t0 = 16,  Sponge (rate 8, capacity 8)
Proposed ZK-SPoW: Width t  = 24,  Compression function (all 24 visible)
\end{Verbatim}

\textbf{Impact on Poseidon2 internals:}

\begin{table}[h]
\centering
\small
\begin{tabular}{@{}llll@{}}
\toprule
Component & Width 16 (standard) & Width 24 (proposed) & Change \\
\midrule
External MDS & 4 M4 blocks & 6 M4 blocks & +50\% additions \\
Internal MDS & 16 multiplications & 24 multiplications & +50\% mult. \\
S-box (external) & 16 per round & 24 per round & +50\% \\
S-box (internal) & 1 per round & 1 per round & unchanged \\
Internal rounds $R_p$ & 14 & 22 & +57\% \\
Total rounds & 22 ($8{+}14$) & 30 ($8{+}22$) & +36\% \\
S-box operations & 142 & 214 & +51\% \\
State registers & $16 \times 31 = 496$ bits & $24 \times 31 = 744$ bits & +50\% \\
\bottomrule
\end{tabular}
\caption{Poseidon2 internals: Width-16 vs Width-24.}
\label{tab:internals}
\end{table}

Internal round MDS scales as $O(t)$, not $O(t^2)$, because the sparse MDS structure (diagonal $+$ rank-1) requires only $t$~multiplications per round. This makes the width extension significantly cheaper than for standard Poseidon.

\textbf{Core area overhead: $+44\%$ (datapath width) to ${\sim}+105\%$ (fully pipelined).} The datapath widens by 50\% ($24/16$), and Width-24 requires $R_p = 22$ internal rounds vs Width-16's $R_p = 14$ (\S\ref{sec:width24sec}), adding $+36\%$ pipeline depth (30 vs 22 total rounds). In an iterative (round-reuse) design, core area increases by ${\sim}+50\%$ (width only) with 36\% more cycles per hash. In a fully pipelined design, core area approximately doubles. Total die area impact: ${\sim}+22\%$ to ${\sim}+50\%$ depending on implementation (Poseidon2 is 50\% of die; see Appendix~\ref{app:asic}). The 3-ticket property yields S-box cost per PoW ticket of $214/3 \approx 71$, a \emph{50\% decrease} compared to Width-16 ($142/1 = 142$), partially offsetting the core count reduction. The usefulness cost is $U = t_0/t = 16/24 \approx 67\%$---the 33\% overhead per permutation serves PoW integration, not ZK computation.

\subsubsection{Compression Function vs Sponge}

Standard Stwo uses sponge mode with 8 hidden capacity elements. This proposal uses \textbf{compression function mode} where all 24 state elements are visible.

\begin{table}[h]
\centering
\begin{tabular}{@{}lll@{}}
\toprule
Property & Sponge (Stwo standard) & Compression (ZK-SPoW) \\
\midrule
Hidden state & 8 capacity elements & None (all visible) \\
Security model & Indifferentiability & Collision/preimage of $\pi$ \\
Perm.\ per Merkle hash & 2 & \textbf{1} \\
Width & 16 & 24 \\
PoW tickets per hash & 0 & \textbf{3} \\
\bottomrule
\end{tabular}
\caption{Sponge vs compression function mode.}
\label{tab:sponge-vs-comp}
\end{table}

Both modes are established Poseidon2 usage modes~\cite{poseidon2}. The Poseidon2 paper recommends compression function mode for Merkle trees, noting up to $5\times$ efficiency over sponge mode in compute-bound settings. On ASIC implementations, STARK Merkle throughput is typically SRAM-bandwidth-bound (see \S\ref{sec:sram}), so the per-permutation efficiency gain manifests as more Poseidon2 cycles available for PoW rather than faster ZK proof generation. Width~24 is within the paper's analyzed parameter range~\cite{poseidon2,plonky3}.

\subsection{I/O Mapping}
\label{sec:io}

For a single Poseidon2 permutation with state $S \in \mathbb{F}_p^{24}$ (compression function mode):

\begin{Verbatim}[fontsize=\small]
INPUT (24 = 8+8+8, all visible):
  S[0..7]    <- left_child      8 M31 elements (248 bits)
  S[8..15]   <- right_child     8 M31 elements (248 bits)
  S[16..23]  <- header_digest   8 M31 elements (248 bits)

          [ Poseidon2 permutation (t = 24) ]
          [ R_f = 8 external + R_p = 22 int ]

OUTPUT (24 = 8+8+8, all visible):
  S[0..7]    -> pow_ticket0     merkle_parent (STARK) AND PoW ticket 0 (248 bits)
  S[8..15]   -> pow_ticket1     PoW ticket 1 (248 bits)
  S[16..23]  -> pow_ticket2     PoW ticket 2 (248 bits)
\end{Verbatim}

Symmetric $8{+}8{+}8$ I/O with no unused output elements. No capacity elements---compression function mode exposes all state elements. Security relies on the Poseidon2 permutation's collision resistance and PRP properties (\S\ref{sec:width24sec}). $S[0..7]$ serves dual roles: it advances the STARK Merkle tree (as $\mathit{merkle\_parent}$) and is checked against the PoW target. Reading $S[0..7]$ for PoW comparison does not modify the value used by the STARK computation.

\textbf{Note on full diffusion:} The Poseidon2 permutation mixes all 24 state elements through its MDS matrix every round. All output elements are functions of all input elements---there is no structural separation between output regions. The $8{+}8{+}8$ labeling is a convention for reading the output, not a property of the permutation. This means $\mathit{merkle\_parent}$ depends on $\mathit{header\_digest}$, and the Stwo-Kaspa verifier must account for this.

\textbf{Dual-use property:}

\begin{table}[h]
\centering
\small
\begin{tabular}{@{}lllllll@{}}
\toprule
Mode & $S[0..7]_{\mathrm{in}}$ & $S[8..15]_{\mathrm{in}}$ & $S[16..23]_{\mathrm{in}}$ & $S[0..7]_{\mathrm{out}}$ & $S[8..15]_{\mathrm{out}}$ & $S[16..23]_{\mathrm{out}}$ \\
\midrule
Symbiotic & left child & right child & $h_H$ & merkle parent + ticket$_0$ & PoW ticket$_1$ & PoW ticket$_2$ \\
Pure PoW & $v_1$ & $v_2$ & $h_H$ & PoW ticket$_0$ & PoW ticket$_1$ & PoW ticket$_2$ \\
\bottomrule
\end{tabular}
\caption{Dual-use I/O mapping.}
\label{tab:dual-use}
\end{table}

The same Poseidon2 hardware computes both modes. Only the input source for $S[0..15]$ differs (SRAM Merkle data vs random nonces). $S[16..23]$ is always $h_H$. \textbf{Each permutation produces 3~PoW tickets}---one from each 8-element output region.

\textbf{Note on ticket granularity.} The $3 \times 8$-element partition is a protocol convention, not a cryptographic constraint. Under PRP, any non-overlapping partition of the 24 output elements yields independent pseudorandom tickets. Finer partitions (e.g., $6 \times 4$ elements at 124 bits each) increase the ticket count but decrease per-ticket bit-length; difficulty adjustment absorbs the ticket count change, leaving per-miner revenue unchanged (\S\ref{sec:econ}). The 8-element grouping is selected for compatibility with Stwo's hash output convention (8 M31 elements = 248 bits) and sufficient difficulty target granularity at network scale.

\subsection{Block Structure}
\label{sec:block}

\textbf{Proposed header} (change from current Kaspa in bold):

\begin{Verbatim}[fontsize=\small]
Header {
  version:                  u16
  parents_by_level:         [[Hash]]       // DAGKnight multi-level parents
  hash_merkle_root:         Hash           // transaction Merkle root
  accepted_id_merkle_root:  Hash
  utxo_commitment:          Hash
  timestamp:                u64            // milliseconds
  bits:                     u32            // difficulty target
  nonce:                    [F_p; 16]      // **64 bytes (currently u64 = 8 bytes)**
  daa_score:                u64
  blue_work:                BlueWorkType
  blue_score:               u64
  pruning_point:            Hash
}
\end{Verbatim}

The only structural change is the nonce expansion from \texttt{u64} (8 bytes) to \texttt{[F\_p; 16]} (64 bytes, +56~bytes per block, ${\sim}0.04\%$ of 125~KB). The nonce maps to Poseidon2 input positions $S[0..15]$ as $(v_1, v_2)$, each 8~M31 elements.

\begin{table}[h]
\centering
\begin{tabular}{@{}lll@{}}
\toprule
 & kHeavyHash (current) & Poseidon2-PoW (proposed) \\
\midrule
Nonce & \texttt{u64} (8 bytes) & \texttt{[F\_p; 16]} (64 bytes) \\
PoW function & kHeavyHash $\to$ 256-bit & Poseidon2 Width-24 $\to$ 248-bit \\
Block hash & Blake2b-256 $\to$ 256-bit & Blake2b-256 $\to$ 256-bit (\textbf{unchanged}) \\
\bottomrule
\end{tabular}
\caption{Block structure comparison.}
\label{tab:block}
\end{table}

\textbf{Block hash vs PoW hash.} Kaspa computes block identity and PoW with separate hash functions. The block hash (Blake2b-256 over the full serialized header including nonce) provides DAG references and block identification---unchanged by this proposal. Only the PoW function is replaced: $h_H = \mathrm{PoseidonSponge}(\text{header excluding nonce})$ is the amortized pre-hash, combined with the nonce in Width-24 Poseidon2 (\S\ref{sec:pow-replacement}). The 248-bit PoW output does not affect the 256-bit block hash.

\textbf{STARK proofs are NOT included in the block.} They are submitted as independent transactions in the mempool, providing economic value to the ZK ecosystem (vProgs fees). This eliminates the +3--5~MB/s bandwidth overhead that would result from mandatory per-block STARK proofs at 100~BPS.

\subsection{Header Digest Collision Resistance}

The header digest $h_H$ compresses the block header (excluding nonce) into $k$ field elements. If $k$ is too small, an attacker can find two headers $H_A \neq H_B$ with identical $h_H$, allowing PoW solutions to be transplanted between conflicting blocks.

\begin{table}[h]
\centering
\begin{tabular}{@{}cccc@{}}
\toprule
$k$ (elements) & Bits & Birthday bound & Security \\
\midrule
1 & 31 & $2^{15} \approx 32$K & INSECURE \\
2 & 62 & $2^{31} \approx 2 \times 10^9$ & INSECURE \\
4 & 124 & $2^{62} \approx 4.6 \times 10^{18}$ & SECURE \\
8 & 248 & $2^{124}$ & Conservative but justified \\
\bottomrule
\end{tabular}
\caption{Header digest collision resistance by element count.}
\label{tab:collision}
\end{table}

\textbf{Minimum: $k = 4$} (124-bit collision resistance). We choose $\mathbf{k = 8}$ (248-bit, matching PoW hash size) to enable symmetric $8{+}8{+}8$ I/O and 3~PoW tickets per permutation. The triple-ticket structure and high permutation rate (${\sim}10^9$/sec per ASIC) make the conservative choice appropriate. Width extension: $t = 16 + 8 = 24$.

% ============================================================
\section{Operating Modes}
\label{sec:modes}

\subsection{Symbiotic Mode (Stwo Prover Active)}
\label{sec:symbiotic}

When ZK proof demand exists, the ASIC runs the Stwo prover. The STARK proof generation pipeline:

\begin{Verbatim}[fontsize=\small]
1. Trace generation       -> circuit evaluation
2. NTT (LDE)              -> polynomial domain extension
3. Merkle tree            -> Poseidon2 hashing (PoW tickets appear here)
4. Fiat-Shamir challenge  -> derived from Merkle root
5. FRI rounds             -> folding + commitment
\end{Verbatim}

At step~3, every Merkle hash is:
\begin{Verbatim}[fontsize=\small]
S = Poseidon2_pi(n_L || n_R || h_H)   // width 24, compression function
merkle_parent = S[0..7]     <- advances STARK proof AND checked as PoW ticket 0
pow_ticket1   = S[8..15]    <- checked against PoW target
pow_ticket2   = S[16..23]   <- checked against PoW target

if S[0..7] < target OR S[8..15] < target OR S[16..23] < target -> BLOCK FOUND
\end{Verbatim}

Every Poseidon2 invocation in the STARK computation simultaneously: \textbf{(a)}~advances the ZK proof (economic value---the useful work that drives the permutation), and \textbf{(b)}~produces PoW tickets (network security---mathematical byproduct of the same permutation).

The miner does not choose the Merkle inputs $(n_L, n_R)$---they are determined by the STARK computation. The ``random exploration'' required for PoW occurs naturally because STARK Merkle tree hashes are pseudorandom from the miner's perspective.

$U = t_0/t = 16/24 \approx 67\%$. The 33\% usefulness gap is the width extension overhead: 8 of 24 input state elements carry $\mathit{header\_digest}$ rather than ZK data. There is no ``ZK only'' mode---every Width-24 permutation produces PoW tickets, regardless of input.

\textbf{Header digest and Merkle tree.} Because Poseidon2's MDS matrix provides full diffusion, the $\mathit{merkle\_parent}$ output depends on $\mathit{header\_digest}$. This means the STARK Merkle tree is bound to a specific block header. At ${\sim}2$G hash/sec, a complete Merkle tree builds within one block interval (10\,ms at 100~BPS). The Stwo-Kaspa verifier reconstructs Merkle nodes using the same Width-24 compression with the known $\mathit{header\_digest}$.

\textbf{Header freshness.} A STARK proof spans multiple Merkle commitment phases (step~3 and FRI rounds)---typically $O(10)$ phases---and takes seconds to complete (dominated by NTT and trace generation). The $\mathit{header\_digest}$ is fixed per Merkle tree phase; each phase completes within one block interval ($<10$\,ms at ${\sim}2$G hash/sec with ${\sim}2.08$G hash throughput per phase). Between phases, the $\mathit{header\_digest}$ register updates to the current block. PoW tickets from each phase are valid for that phase's header. Maximum staleness is 1~block (10\,ms): a PoW ticket found at the end of a Merkle phase references a $\mathit{header\_digest}$ that is at most one block behind the DAG tip. In DAGKnight's DAG structure~\cite{dagknight}, this is well within tolerance---DAGKnight accepts blocks with parent sets up to $k$ blocks deep (where $k$ is the anticone parameter, typically $k \geq 10$ at 100~BPS), and 1-block staleness is indistinguishable from normal parallel block production.

\subsection{Pure PoW Mode (No ZK Demand)}
\label{sec:pure-pow}

When no ZK proofs are requested:
\begin{Verbatim}[fontsize=\small]
loop:
  v1 = next_nonce_1()
  v2 = next_nonce_2()
  S = Poseidon2_pi(v1 || v2 || h_H)   // width 24, compression function
  if S[0..7] < target OR S[8..15] < target OR S[16..23] < target -> BLOCK FOUND
\end{Verbatim}

Identical Poseidon2 pipeline, identical throughput. The only difference is the input source: random/sequential nonces instead of STARK Merkle children.

$U = 0\%$. No ZK proof is being computed. The ASIC provides network security only, equivalent to any conventional PoW miner. This is not waste---security has value---but it is not useful work in the ZK-SPoW sense.

\subsection{Linear Mode Transition}

\begin{Verbatim}[fontsize=\small]
+-- Poseidon2 Pipeline (always 100% utilized) ---------+
|                                                       |
|  Input MUX (per-cycle decision):                      |
|    SRAM data ready  -> STARK Merkle hash (Symbiotic)  |
|    SRAM not ready   -> PoW nonce hash    (PoW)        |
|                                                       |
|  Switching cost: 0 cycles (combinational MUX, ~300 G) |
|  Hashrate: invariant across all modes                 |
+-------------------------------------------------------+
\end{Verbatim}

The transition between Symbiotic and Pure PoW is \textbf{per-cycle and linear}, not a discrete mode switch. When the Poseidon2 pipeline is executing STARK computation, that cycle is Symbiotic. When SRAM data is not ready, a random nonce hash is substituted and that cycle is PoW. The pipeline is always full---the ratio of Symbiotic to PoW cycles is determined by SRAM bandwidth, not by difficulty or protocol parameters.

\subsection{Hashrate Invariance}

\begin{proposition}
Total PoW hashrate $\mathcal{H}$ is independent of the operating mode.
\end{proposition}
\begin{proof}[Argument]
$\mathcal{H} = N_{\mathrm{cores}} \times \mathrm{throughput\_per\_core}$. Each core's throughput is 1~hash per $\mathrm{pipeline\_depth}$ cycles (fully pipelined), regardless of whether the input is a STARK Merkle pair or a random nonce. Input MUX adds zero latency (combinational logic). Therefore $\mathcal{H}$ is constant across Symbiotic, Pure PoW, and any mixed state.
\end{proof}

\subsection{Difficulty Independence}

$U$ is determined by ZK demand and width ratio, not by PoW difficulty.

\begin{table}[h]
\centering
\begin{tabular}{@{}lcl@{}}
\toprule
Condition & $U$ & Rationale \\
\midrule
Stwo Prover active, any difficulty & $\approx 67\%$ & ZK proof, minus width overhead \\
No ZK demand, any difficulty & $0\%$ & Pure PoW = security only \\
\bottomrule
\end{tabular}
\caption{Usefulness is independent of difficulty.}
\label{tab:difficulty}
\end{table}

Difficulty affects how many hashes are needed to find a block, but does not change $U$. Whether difficulty is 8M or 188G, the ASIC either computes ZK proofs ($U \approx 67\%$) or grinds nonces ($U = 0\%$). The ratio of STARK-to-PoW cycles within the pipeline is determined by SRAM bandwidth (a hardware constant), not by the network's difficulty target.

\subsection{Complementary Bottleneck Structure}
\label{sec:bottleneck}

The simultaneous execution of PoW and STARK is possible because they bottleneck on different resources:

\begin{table}[h]
\centering
\begin{tabular}{@{}lcccc@{}}
\toprule
Resource & PoW & STARK & Combined \\
\midrule
Poseidon2 cores & \textbf{100\%} (compute-bound) & Low (SRAM-starved) & ${\sim}$\textbf{100\%} \\
NTT unit & 0\% & \textbf{100\%} & \textbf{100\%} \\
SRAM bandwidth & 0\% (registers only) & \textbf{100\%} (memory-bound) & \textbf{100\%} \\
\bottomrule
\end{tabular}
\caption{Complementary bottleneck structure.}
\label{tab:bottleneck}
\end{table}

PoW is compute-bound (limited by Poseidon2 throughput). STARK is memory-bound (limited by SRAM bandwidth feeding Merkle data to Poseidon2). They share Poseidon2 cores but contend on different bottleneck resources, achieving near-perfect utilization of all hardware components simultaneously. Under 200~GB/s SRAM bandwidth, the STARK allocation is $f_{\mathrm{sym}} \approx 10\%$ of Poseidon2 cycles, yielding $U_{\mathrm{avg}} = f_{\mathrm{sym}} \times U \approx 6.7\%$ time-averaged usefulness (see \S\ref{sec:sram} for derivation). This complementary structure is the foundation of the economic analysis in \S\ref{sec:pareto}.

\textbf{Width-24 efficiency.} Width-24 compression uses 1~permutation per Merkle hash versus Width-16 sponge's 2~permutations. This halves STARK's Poseidon2 cycle consumption, freeing more cycles for PoW. The STARK proof generation rate itself remains SRAM-bandwidth-bound (see \S\ref{sec:sram} for quantitative analysis).

% ============================================================
\section{Pareto Analysis}
\label{sec:pareto}

\subsection{Competing Designs}

Four designs compared under identical die area and power budget:

\begin{table}[h]
\centering
\small
\begin{tabular}{@{}llcccc@{}}
\toprule
Design & Die allocation & Hashrate & ZK & $U$ & Mine? \\
\midrule
Pure PoW & 95\% Pos2, 5\% ctrl & ${\sim}1.9\,\mathcal{H}$ & 0 & 0\% & Yes \\
Pure Stwo & 20\% Pos2, 40\% NTT, 35\% SRAM & 0 & $Z_{\max}$ & 100\% & No \\
\textbf{ZK-SPoW} & \textbf{50\% Pos2, 25\% NTT, 20\% SRAM} & $\mathcal{H}$ & $Z$ & $\mathbf{{\approx}67\%}$ & \textbf{Yes} \\
ZK-SPoW+HBM & 50\% Pos2, 25\% NTT, 20\% HBM & $\mathcal{H}$ & $Z_{\mathrm{hbm}}$ & ${\approx}67\%$ & Yes \\
\bottomrule
\end{tabular}
\caption{Pareto comparison of competing designs.}
\label{tab:pareto}
\end{table}

Pure PoW achieves ${\sim}1.9\times$ hashrate on a die-area basis (95\%/50\% Poseidon2 allocation) but produces no ZK proofs ($U = 0\%$). On a hashes-per-watt basis, the gap narrows to ${\sim}1.1$--$1.2\times$ because idle NTT and SRAM contribute static leakage (${\sim}10$--$20\%$ of dynamic power; varies by process node). Pure Stwo uses standard Width-16 cores ($U = 100\%$) but cannot mine. ZK-SPoW achieves $U \approx 67\%$ and mining capability---the 33\% usefulness gap is the cost of PoW integration via width extension.

\subsection{Economic Dominance}
\label{sec:econ}

Difficulty adjusts to total network hashrate. When all $N$ miners use the same design, per-ASIC mining revenue is $B/N$ regardless of absolute hashrate. The differentiator is ZK revenue:
\[
\text{ZK-SPoW revenue} = B/N + Z \cdot F \;>\; B/N = \text{Pure PoW revenue} \quad (\text{for any } ZF > 0)
\]

Pure PoW's ${\sim}1.1$--$1.2\times$ power-efficiency advantage yields at most ${\sim}10$--$20\%$ more mining revenue per watt in a mixed network. Once ZK fee income $Z \cdot F$ exceeds this margin, ZK-SPoW dominates. The crossover point depends on Kaspa's ZK market development, network growth trajectory, and adoption dynamics---detailed economic modeling is required for quantitative predictions.

\textbf{PoW security without ZK demand.} ZK-SPoW does not condition PoW security on ZK demand. When $Z \cdot F = 0$ (no ZK market), the ASIC operates as a conventional PoW miner with a hash/watt disadvantage due to the die area overhead (\S\ref{sec:design-c}). Difficulty adjustment absorbs this: in a homogeneous ZK-SPoW network, per-ASIC mining revenue is identical to a homogeneous Pure PoW network. The die overhead is the cost of optionality---it purchases the ability to capture ZK revenue when the market emerges, without sacrificing PoW security in the interim.

% ============================================================
\section{Security Considerations}
\label{sec:security}

\subsection{Poseidon2 Cryptographic Properties}

Poseidon2~\cite{poseidon2} provides 128-bit security in sponge mode with capacity $c = 8$ M31 elements (248 bits). In compression function mode (ZK-SPoW), security relies on collision resistance and preimage resistance of the permutation---well-established properties within the Poseidon2 framework~\cite{poseidon2}. Known algebraic attack vectors (Gr\"obner basis, interpolation, differential) have been analyzed for standard parameters. StarkWare has adopted Poseidon2 for production use in Starknet, representing significant implicit endorsement of its security.

\textbf{Note:} All security claims in this paper assume final production round constants. The current Stwo implementation uses placeholder values (see \S\ref{sec:open}).

\subsection{Single Primitive Dependency}

\begin{table}[h]
\centering
\begin{tabular}{@{}lll@{}}
\toprule
Component & Current Kaspa & Proposed \\
\midrule
PoW & kHeavyHash (Blake2b + cSHAKE256) & Poseidon2 \\
STARK & Poseidon2 & Poseidon2 \\
Independence & PoW $\neq$ STARK & PoW = STARK \\
\bottomrule
\end{tabular}
\caption{Single primitive dependency.}
\label{tab:dependency}
\end{table}

\textbf{Risk:} A cryptographic break in Poseidon2 compromises both PoW security and STARK validity simultaneously. This concentration risk is shared with the broader Poseidon2 ecosystem (notably Starknet).

\subsection{Width-24 Security}
\label{sec:width24sec}

\textbf{Collision resistance (STARK binding).} STARK Merkle tree integrity requires collision resistance of the Width-24 compression function. With 248-bit output (8 M31 elements), the birthday bound is $2^{124}$, providing 124-bit collision security. Width-24 provides strictly more state than Width-16 (24 vs 16 elements), resulting in stronger diffusion and larger algebraic degree accumulation. This is within \cite{poseidon2}'s analyzed parameter range.

\textbf{STARK soundness.} The $\mathit{header\_digest}$ acts as a fixed salt in each Merkle hash: it is determined by the block header before proof generation begins and cannot be chosen adaptively by the prover. STARK soundness therefore reduces to collision resistance of the Width-24 compression function with a fixed third input---a strictly easier assumption than collision resistance under adversarially chosen inputs. The Stwo-Kaspa verifier reconstructs Merkle nodes using the same $\mathit{header\_digest}$, preserving the binding property.

\textbf{Preimage resistance (PoW security).} PoW requires only preimage resistance of the 248-bit output---trivially satisfied by 30 rounds of Poseidon2 (8 external + 22 internal).

\textbf{$R_p$ for Width-24.} The internal round count increases from $R_p = 14$ (Width-16) to $R_p = 22$ (Width-24) for 128-bit security at $D = 5$ over M31. This is confirmed by Plonky3's verified round number computation~\cite{plonky3}, which applies the security constraints from \cite{poseidon,poseidon2} plus the algebraic attack bound from Khovratovich et al.\ (ePrint 2023/537), with a security margin of $R_f \mathrel{{+}{=}} 2$, $R_p \times 1.075$. The binding constraint is statistical ($R_f \geq 6$). Total rounds: 30 ($8 + 22$) vs 22 ($8 + 14$) for Width-16. Despite 51\% more S-box operations per permutation (214 vs 142), the per-ticket cost \emph{decreases} by 50\% ($214/3 \approx 71$ vs $142/1 = 142$ S-boxes per PoW ticket) due to the triple-ticket structure. Supplementary verification: $M_I^k$ is invertible for all $k = 1..48$ (necessary condition for subspace trail resistance~\cite{poseidon2}). Diffusion analysis confirms full input-to-output dependency from the first external round. Algebraic degree after the full 30-round permutation exceeds $2^{69}$, well above the $2^{64}$ threshold for interpolation security at 128 bits.

\subsection{PoW Hash Distribution}
\label{sec:pow-dist}

All three output regions---$\mathit{pow\_ticket}_0 = S[0..7]$, $\mathit{pow\_ticket}_1 = S[8..15]$, and $\mathit{pow\_ticket}_2 = S[16..23]$---are outputs of the same Poseidon2 permutation. In compression function mode, all 24 state elements are visible by design. Security relies on the permutation's PRP properties: given a random-looking input, all output elements should be indistinguishable from random. The three PoW tickets are deterministically linked (same permutation), but each is individually pseudorandom. An attacker who could predict one ticket from another without computing the full permutation would violate the PRP assumption---equivalent to breaking Poseidon2. The full-round permutation (8 external + 22 internal) ensures all output elements are cryptographically mixed across all 24 state positions.

\textbf{Triple-ticket mining:} Under the PRP assumption on Poseidon2, the three tickets are mutually independent (Appendix~\ref{app:triple-ticket}). With three 248-bit tickets per permutation, the per-permutation success probability is exact:
\[
P(\text{valid}) = 1 - (1 - p)^3 = 3p - 3p^2 + p^3, \quad p = T/2^{248}
\]

Note that the number of tickets per permutation does not affect mining economics in a homogeneous network: difficulty adjustment absorbs any change in per-permutation success probability, leaving per-miner revenue at $B/N$ (\S\ref{sec:econ}). The triple-ticket structure is a natural consequence of Width-24's symmetric $8{+}8{+}8$ output and Stwo's 8-element hash convention, not a hashrate optimization.

\subsection{Quantum Resistance}

Poseidon2's security against quantum adversaries:
\begin{itemize}
\item Grover's algorithm halves the effective hash bits: $248/2 = 124$-bit quantum security
\item Comparable to SHA-256 under quantum attack ($256/2 = 128$ bits)
\item kHeavyHash: $256/2 = 128$-bit quantum security
\item \textbf{Delta:} $-8$ bits classical (248 vs 256) / $-4$ bits quantum (124 vs 128) from the transition. Both values remain well above the 100-bit security floor considered acceptable for PoW functions.
\end{itemize}

% ============================================================
\section{Comparison with Prior Work}
\label{sec:comparison}

\subsection{Design Evolution}

Five architectures were explored over multiple sessions before converging on ZK-SPoW:

\begin{table}[h]
\centering
\small
\begin{tabular}{@{}clll@{}}
\toprule
\# & Architecture & Verdict & Primary rejection reason \\
\midrule
1 & Core Division ($\alpha = 1\%$) & Practical & $U = 1\%$, cannot claim symbiosis \\
2 & Rate-4 Poseidon & Theoretical & FRI cascade cost, timing misalignment \\
3 & ZK-Symbiotic (HW multithread) & Best engineering & Not PoUW by~\cite{ball2017} \\
4 & MatMul PoUW~\cite{komargodski2025} & Domain-specific & $O(n^3)$ verification, 100~BPS \\
5 & Direction~C (Pure ZK PoUW) & Unsolved & Fiat-Shamir cascade barrier \\
\bottomrule
\end{tabular}
\caption{Design evolution.}
\label{tab:evolution}
\end{table}

The final design synthesizes insights from Architecture~\#2 (dual-use Poseidon outputs) and Architecture~\#3 (hardware multithreading with low-cost context switch), while avoiding their individual weaknesses:
\begin{itemize}
\item From \#2: The idea that STARK intermediate hashes can serve as PoW tickets
\item From \#3: The MUX-based switching between STARK and PoW input sources
\item Resolved \#2's FRI cascade problem by treating re-computation as useful work
\item Resolved \#3's classification by the PoUW paradox inversion (\S\ref{sec:pouw-paradox})
\end{itemize}

\subsection{Key Design Decisions}

\begin{table}[h]
\centering
\small
\begin{tabular}{@{}llp{0.40\textwidth}@{}}
\toprule
Decision & Choice & Rationale \\
\midrule
STARK proof in block? & \textbf{No} (Option~C) & Eliminates +3--5~MB/s at 100~BPS \\
Hash function & \textbf{Poseidon2} & Stwo-Kaspa compatibility \\
Field & \textbf{M31} & Stwo standard (smallest multiplier, highest core density) \\
Permutation width & \textbf{24} (from 16) & 1~perm/hash + triple tickets; $U \approx 67\%$; ZK rate SRAM-bound \\
Operating mode & \textbf{Compression} & 1~perm/hash (vs 2 in sponge); recommended by~\cite{poseidon2} \\
PoW tickets/hash & \textbf{3} & $S[0..7]$, $S[8..15]$, $S[16..23]$; natural 8-element grouping \\
PoW hash size & \textbf{248 bits} & 8~M31 elements; close to 256-bit class ($-$8 bits) \\
Header digest & \textbf{8} (248 bits) & Birthday bound $2^{124}$; matches PoW hash size \\
STARK enforcement & \textbf{None} & Market-driven ZK adoption; avoids bandwidth penalty \\
Nonce structure & $\mathbf{(v_1, v_2)} \times 8$ & 64 bytes; maps to Merkle child pair in Symbiotic mode \\
Verifier & \textbf{Stwo-Kaspa} & Width-24 Poseidon2 compression; parameter change within~\cite{poseidon2}'s framework \\
\bottomrule
\end{tabular}
\caption{Key design decisions.}
\label{tab:decisions}
\end{table}

\textbf{Option~C rationale:} Three options were evaluated for STARK enforcement:

\begin{table}[h]
\centering
\small
\begin{tabular}{@{}llll@{}}
\toprule
Option & STARK requirement & Bandwidth impact & ZK-SPoW benefit \\
\midrule
A & Every block & +3--5~MB/s & Maximum (strict ZK binding) \\
B & Every $N$ blocks & +50~KB/s ($N{=}100$) & Partial \\
\textbf{C} & \textbf{None} & \textbf{None} & \textbf{Market-driven ($U{\approx}67\%$ when ZK active)} \\
\bottomrule
\end{tabular}
\caption{Option~C rationale: STARK enforcement alternatives.}
\label{tab:option-c}
\end{table}

Option~C was selected because it preserves Kaspa's existing bandwidth profile while enabling symbiotic operation through economic incentives rather than protocol enforcement.

\subsection{Relationship to Ball et al.}

Ball et al.~\cite{ball2017} formalize PoUW in the direction \textbf{PoW $\to$ useful output}. ZK-SPoW operates in the inverse direction: \textbf{useful computation $\to$ PoW output}.

\begin{table}[h]
\centering
\small
\begin{tabular}{@{}lll@{}}
\toprule
Ball et al.\ criterion & PoW $\to$ useful (their framework) & Useful $\to$ PoW (ZK-SPoW) \\
\midrule
Produces useful output & Partial: PoW-fill = security-only & \textbf{Yes}: every Symbiotic perm \\
Verifier confirms & Not enforced (Option~C) & STARK proofs publicly checkable \\
Bound to PoW & Not enforced & \textbf{Inherent}: same permutation \\
\bottomrule
\end{tabular}
\caption{Relationship to Ball et al.~\cite{ball2017}.}
\label{tab:ball}
\end{table}

Under their original framework (PoW $\to$ useful), ZK-SPoW satisfies 0 of 3 criteria strictly. Under the inverted framing (useful $\to$ PoW), the evaluation changes: the STARK computation drives the permutation, PoW tickets are a cryptographically bound byproduct, and the proof is publicly verifiable.

The deeper point: Ball et al.'s hardness results~\cite{ball2017} constrain the PoW $\to$ useful direction. ZK-SPoW sidesteps these constraints by never attempting to make PoW useful. Instead, useful computation (STARK proving) happens to produce PoW-valid outputs because Poseidon2's pseudorandom outputs naturally fall below the target at the expected rate.

Ofelimos~\cite{ofelimos} is the closest prior work, using SNARK proofs as useful work within a provably secure PoUW framework. Komargodski et al.~\cite{komargodski2025,baron2025} explore PoUW via matrix multiplication and external utility functions. ZK-SPoW differs from both: (1)~the useful computation is market-driven rather than protocol-mandated (Option~C), and (2)~PoW tickets emerge as a byproduct of STARK hashing rather than through a separate verification mechanism.

% ============================================================
\section{Open Questions}
\label{sec:open}

\begin{enumerate}
\item \textbf{Stwo production parameters.} The baseline parameters (Width~16, Rate~8, Capacity~8, $R_f = 8$, $R_p = 14$) are confirmed from source code~\cite{stwo}. However, round constants are explicit placeholders (\texttt{1234}; see TODO in source). Final production constants are required before security analysis can be completed.

\item \textbf{$R_p$ for Width-24 (resolved).} $R_p = 22$ confirmed via Plonky3~\cite{plonky3}. See \S\ref{sec:width24sec}.

\item \textbf{Stwo-Kaspa verifier.} Width-24 Poseidon2 compression is a different cryptographic function from Width-16 sponge (different MDS matrix, different round count). A Kaspa-specific verifier is required. Plonky3~\cite{plonky3} already provides a production Width-24 Poseidon2 implementation over M31 with verified parameters: external MDS $= \mathrm{circ}(2M_4, M_4, \ldots, M_4)$; internal MDS $= \mathbf{1}\mathbf{1}^\top + \mathrm{diag}(V)$ with $V = [-2, 1, 2, 4, \ldots, 2^{22}]$; $R_f = 8$, $R_p = 22$. The remaining requirements are: (a)~round constant finalization (Grain LFSR or PRNG; both Stwo and Plonky3 currently use non-production constants), (b)~integration with Stwo's proof system, (c)~independent security certification. StarkWare's willingness to accept Width-24 as an upstream configuration option determines whether this is a lightweight fork or a permanent maintenance burden.

\item \textbf{Hard fork governance.} Transitioning from kHeavyHash to Poseidon2 renders existing kHeavyHash ASICs obsolete and requires community consensus.

\item \textbf{Mining pool protocol.} The 64-byte nonce (vs current 8-byte) requires updates to the stratum protocol for nonce range distribution. Stratum~V2 may accommodate this natively.

\item \textbf{ZK market maturity.} The economic advantage of ZK-SPoW over Pure PoW depends on sufficient ZK proof demand. The timeline for this market to develop is uncertain and requires dedicated economic modeling.

\item \textbf{Complementary bottleneck validation.} The claim that PoW (compute-bound) and STARK (memory-bound) can run simultaneously at full throughput requires hardware-level validation on actual ASIC designs.

\item \textbf{Triple-ticket independence (resolved).} Under the PRP assumption, for any fixed input $x$, the permutation output $\pi(x)$ is uniformly distributed over $\mathbb{F}_p^{24}$. A uniform distribution on the product space $\mathbb{F}_p^8 \times \mathbb{F}_p^8 \times \mathbb{F}_p^8$ implies that $S[0..7]$, $S[8..15]$, $S[16..23]$ are mutually independent. The joint success probability $q = 1 - (1-p)^3 = 3p - 3p^2 + p^3$ is therefore exact. Any detectable correlation would constitute a PRP distinguisher---equivalent to breaking Poseidon2. See Appendix~\ref{app:triple-ticket}.

\item \textbf{Trace grinding (resolved).} Under the PRP assumption on Poseidon2, trace selection does not affect the PoW ticket success distribution. The total number of permutations across all STARK commitment phases (initial Merkle tree plus FRI rounds) is determined by protocol parameters and is invariant under trace selection. Each permutation produces three PoW tickets whose joint success probability $q = 1-(1-p)^3 \approx 3p$, $p = T/2^{248}$, is input-independent under PRP. The distribution of valid tickets follows $\mathrm{Binomial}(P,\, q)$ where $P$ is the total permutation count---invariant across trace choices. Multi-trial grinding ($k$ distinct traces, selecting the best outcome) incurs $(k-1)/k$ waste from discarded proofs, yielding net loss for $k \geq 2$. Header digest ($h_H$) selection is equivalent to nonce grinding under PRP. See Appendix~\ref{app:tracegrinding} for the full proof.
\end{enumerate}

% ============================================================
\appendix

\section{ASIC Architecture Details}
\label{app:asic}

\subsection{ZK-Symbiotic ASIC Block Diagram}

\begin{Verbatim}[fontsize=\scriptsize]
+-- ZK-SPoW ASIC (7nm, ~200W) -----------------------------------------+
|                                                                        |
|  +-- Poseidon2 Core Array (50% die) --------------------------------+ |
|  |                                                                    | |
|  |  [Core 0] [Core 1] [Core 2] ... [Core N-1]                        | |
|  |  Each core: Width-24 Poseidon2 pipeline (M31)                     | |
|  |  Mode: Symbiotic (STARK Merkle) or PoW (nonce), per-cycle MUX    | |
|  |                                                                    | |
|  |  Per-Core:  [Input MUX] -> [Poseidon2 Pipeline R1..R30] ->        | |
|  |             [Output Router: SRAM write / target comparator]        | |
|  +--------------------------------------------------------------------+ |
|                                                                        |
|  +-- NTT Butterfly Unit (25% die) ----------------------------------+ |
|  |  M31 multiply-accumulate array                                     | |
|  |  STARK: polynomial LDE + FRI folding                               | |
|  |  PoW mode: idle (future: repurpose for other useful computation)   | |
|  +--------------------------------------------------------------------+ |
|                                                                        |
|  +-- SRAM (20% die) ------------------------------------------------+ |
|  |  32 MB on-chip, ~200 GB/s bandwidth                                | |
|  |  STARK: eval values, Merkle tree nodes, FRI intermediate data      | |
|  |  PoW mode: unused (Poseidon2 runs from registers only)             | |
|  +--------------------------------------------------------------------+ |
|                                                                        |
|  +-- Control & I/O (5% die) ----------------------------------------+ |
|  |  PoW controller, STARK controller, scheduler, network interface    | |
|  +--------------------------------------------------------------------+ |
+------------------------------------------------------------------------+
\end{Verbatim}

\subsection{Poseidon2 Core Circuit (M31)}

\subsubsection{M31 Field Arithmetic}

\textbf{Modular multiplication:}
\begin{Verbatim}[fontsize=\small]
a, b in F_p  where p = 2^31 - 1

c = a * b                      // 31 x 31 -> 62-bit product
c_hi = c[61:31]                // upper 31 bits
c_lo = c[30:0]                 // lower 31 bits
result = c_hi + c_lo           // Mersenne reduction
if result >= p: result -= p    // final correction
\end{Verbatim}

Mersenne property: $2^{31} \equiv 1 \pmod{p}$, so the upper bits fold directly into the lower bits with a single addition.

\begin{table}[h]
\centering
\begin{tabular}{@{}lll@{}}
\toprule
Metric & M31 & Goldilocks ($2^{64} - 2^{32} + 1$) \\
\midrule
Multiplier width & $31 \times 31 \to 62$ bit & $64 \times 64 \to 128$ bit \\
Reduction & 1 addition & shift + sub + add \\
Gate count & ${\sim}1{,}000$ & ${\sim}3{,}500$ \\
Latency & 1 cycle & 2--3 cycles \\
Area ratio & $\mathbf{1\times}$ & $3.5\times$ \\
\bottomrule
\end{tabular}
\caption{M31 vs Goldilocks field arithmetic.}
\label{tab:m31-gold}
\end{table}

\textbf{M31 advantage:} $3.5\times$ more multipliers per die $\to$ $3.5\times$ more Poseidon2 cores $\to$ proportionally higher hashrate.

\subsubsection{S-box: $x^5 \bmod p$}

\begin{Verbatim}[fontsize=\small]
x --> [MUL] --> x^2
       [MUL] --> x^4 = (x^2)^2
       [MUL] --> x^5 = x^4 * x

Critical path: 3 sequential multiplications
Multipliers per S-box: 3 (with x^2 reuse)
Gate count (M31): 3 x 1,000 = ~3,000 gates
\end{Verbatim}

\subsubsection{MDS Matrix (Poseidon2)}

\textbf{External rounds} use a block-circulant structure based on the Stwo/HorizenLabs M4:
\[
M_4 = \begin{pmatrix} 5 & 7 & 1 & 3 \\ 4 & 6 & 1 & 1 \\ 1 & 3 & 5 & 7 \\ 1 & 1 & 4 & 6 \end{pmatrix}
\]
For each 4-element group:
\begin{Verbatim}[fontsize=\small]
s0' = 5*s0 + 7*s1 + s2 + 3*s3
s1' = 4*s0 + 6*s1 + s2 + s3
s2' = s0 + 3*s1 + 5*s2 + 7*s3
s3' = s0 + s1 + 4*s2 + 6*s3

Coefficients in {1,3,4,5,6,7} -- all shift+add, no multipliers
\end{Verbatim}
Width~24 = 6 groups of 4 $\to$ 6 M4 applications $\to$ \textbf{shift+add only} in external MDS.

\textbf{Internal rounds} use sparse MDS: $M_I = \mathbf{1}\mathbf{1}^\top + \mathrm{diag}(V)$, where $V = [-2, 1, 2, 4, \ldots, 2^{22}]$ (Plonky3 production values~\cite{plonky3}):
\begin{Verbatim}[fontsize=\small]
sum = s0 + s1 + ... + s_{t-1}         // t-1 additions
s_i' = V[i] * s_i + sum               // V[i] in {powers of 2, -2} -> shift+add

Width 16 (standard): 16 multiplications per internal round
Width 24 (extended): 24 multiplications per internal round  (+50%)
\end{Verbatim}

\subsubsection{Full Round vs Partial Round}

\begin{table}[h]
\centering
\begin{tabular}{@{}lll@{}}
\toprule
Component & External round ($\times 8$) & Internal round ($\times 22$) \\
\midrule
S-box & $24 \times 3$K $= 72$K gates & $1 \times 3$K $= 3$K gates \\
MDS & M4 blocks (${\sim}12$K gates) & diag $+ \mathbf{1}\mathbf{1}^\top$ (${\sim}24$K gates) \\
Round constants & $24 \times 100 = 2.4$K & $2.4$K \\
\textbf{Subtotal} & $\mathbf{{\sim}86}$\textbf{K gates} & $\mathbf{{\sim}29}$\textbf{K gates} \\
\bottomrule
\end{tabular}
\caption{Per-round gate counts.}
\label{tab:rounds}
\end{table}

\textbf{Total core (pipelined):}
\[
8 \times 86\text{K} + 22 \times 29\text{K} = 688\text{K} + 638\text{K} \approx 1{,}326\text{K gates (Width 24)}
\]
Standard Width~16: $8 \times 58\text{K} + 14 \times 21\text{K} = 464\text{K} + 294\text{K} \approx 758\text{K gates}$. Overhead: $+75\%$ core logic.

\subsection{Pipeline Design Options}

\subsubsection{Folded (Area Minimal)}
\begin{Verbatim}[fontsize=\small]
1 round of hardware x 30 iterations

Area: ~86K gates (one external round circuit, shared)
Throughput: 1 hash / 30 cycles per core
@ 1 GHz: ~33M perm/sec per core -> 100M effective hash/sec (3 tickets)
\end{Verbatim}

\subsubsection{Full Pipeline (Throughput Maximal)}
\begin{Verbatim}[fontsize=\small]
30 stages, all rounds instantiated

Area: ~1.4M gates per core (1,326K logic + 108K registers + 3K control)
Throughput: 1 perm / cycle per core (after pipeline fill)
Latency: 30 cycles
@ 1 GHz: 1G perm/sec -> 3G effective hash/sec (3 tickets)
\end{Verbatim}

\subsubsection{Partial Pipeline (Balanced)}
\begin{Verbatim}[fontsize=\small]
k stages x (30/k) iterations

k=5:  ~300K gates, 1 perm / 6 cycles  -> ~167M perm/sec -> 500M eff
k=10: ~550K gates, 1 perm / 3 cycles  -> ~333M perm/sec -> 1G eff
k=15: ~700K gates, 1 perm / 2 cycles  -> ~500M perm/sec -> 1.5G eff
\end{Verbatim}

\subsubsection{Die-Level Comparison}

Assuming 60M gate die, 50\% allocated to Poseidon2 cores (30M gates). Each permutation produces \textbf{3 PoW tickets}:

\begin{table}[h]
\centering
\begin{tabular}{@{}lcccc@{}}
\toprule
Pipeline style & Gates/core & Cores & Perm/sec/core & Effective hash/sec \\
\midrule
Folded ($\times 1$) & 86K & 348 & 33M & \textbf{35G} \\
5-stage & 300K & 100 & 167M & \textbf{50G} \\
10-stage & 550K & 54 & 333M & \textbf{54G} \\
Full ($\times 30$) & 1.4M & 21 & 1G & \textbf{63G} \\
\bottomrule
\end{tabular}
\caption{Die-level comparison (60M gate die, 50\% to Poseidon2, 3 tickets/perm).}
\label{tab:pipeline}
\end{table}

Full pipeline achieves highest throughput. The 3-ticket multiplier makes full pipeline particularly effective.

\subsection{Header Pre-absorption}

Block header $H$ is variable-length (parents, tx\_root, timestamp). Hashing it every nonce attempt is wasteful.

\textbf{Optimization:} pre-absorb header into Poseidon2 sponge state.
\begin{Verbatim}[fontsize=\small]
On header change (~100 times/sec at 100 BPS):
  h_H = PoseidonSponge(parent_hashes || tx_merkle_root || timestamp)
  -> 8 M31 elements, stored in header_state register

Per nonce attempt (compression function mode, width 24):
  S[0..7]   <- v1   (nonce part 1)
  S[8..15]  <- v2   (nonce part 2)
  S[16..23] <- h_H  (from register, constant)
  -> 1 Poseidon2 permutation (30 rounds)
  -> output S[0..7], S[8..15], and S[16..23] compared against target (3 tickets)
\end{Verbatim}

\textbf{Cost per nonce:} exactly 1 Poseidon2 permutation. Header pre-hash is amortized across ${\sim}10$M nonce attempts per header change.

Hardware for pre-absorption: $\mathit{header\_state}$ register: $8 \times 31$ bits $= 248$ bits (${\sim}400$ gates). Negligible compared to Poseidon2 core (${\sim}1.4$M gates).

\subsection{SRAM Bandwidth and Throughput Allocation}
\label{sec:sram}

\subsubsection{STARK Memory Access Pattern}

Each Poseidon2 Merkle hash requires:
\begin{Verbatim}[fontsize=\small]
Read:  left_child  = 8 x 4 bytes = 32 bytes
Read:  right_child = 8 x 4 bytes = 32 bytes
Write: parent_node = 8 x 4 bytes = 32 bytes
Total: 96 bytes per hash
\end{Verbatim}

\subsubsection{Throughput Calculation}
\begin{align*}
\text{SRAM bandwidth} &\approx 200~\text{GB/s} \\
\text{Bytes per STARK hash} &= 96 \\
\text{STARK hash throughput} &= 200\text{G}/96 \approx 2.08\text{G hash/sec} \\
\text{Total Poseidon2 throughput} &\approx 21\text{G perm/sec (21 cores @ 1\,GHz)} \\
\text{Effective PoW hashrate} &\approx 63\text{G hash/sec (3 tickets/perm)} \\
\text{STARK allocation: } f_{\mathrm{sym}} &= 2.08/21 \approx 9.9\%
\end{align*}

\subsubsection{Interpretation}

\begin{table}[h]
\centering
\begin{tabular}{@{}lll@{}}
\toprule
Metric & Value & Note \\
\midrule
Hardware STARK fraction ($f$) & ${\sim}10\%$ & SRAM-bandwidth limited \\
Hardware PoW fraction & ${\sim}90\%$ & Fills idle Poseidon2 cycles \\
$U$ (usefulness) & $\approx 67\%$ & $t_0/t = 16/24$; width extension overhead = 33\% \\
STARK proofs/sec & ${\sim}260$ & $2.08\text{G}/8\text{M hashes per proof}$ \\
PoW hashrate & ${\sim}63$G effective & $21\text{G perm/sec} \times 3$ tickets \\
$U_{\mathrm{avg}}$ & $\approx 6.7\%$ & $f \times U = 0.10 \times 0.67$ \\
\bottomrule
\end{tabular}
\caption{Throughput allocation summary.}
\label{tab:throughput}
\end{table}

\textbf{Time-averaged usefulness.} $U_{\mathrm{avg}} = f_{\mathrm{sym}} \times U \approx 0.10 \times 0.67 \approx 6.7\%$ under 200~GB/s SRAM bandwidth with the STARK prover continuously active. This means 6.7\% of all Poseidon2 cycles advance ZK proofs; the remaining 93.3\% provide PoW security only. In a conventional PoW network, $U_{\mathrm{avg}} = 0\%$: all mining energy produces security and nothing else. ZK-SPoW's 6.7\% represents computation that would otherwise have no useful output beyond block validation. $U_{\mathrm{avg}}$ scales with memory bandwidth: ${\sim}13\%$ at 400~GB/s, ${\sim}40\%$ at 1.2~TB/s (\S\ref{sec:sram-scaling}). When the STARK prover is inactive (no ZK demand), $U_{\mathrm{avg}} = 0\%$ and the ASIC operates as a conventional PoW miner.

\textbf{$f$ is not waste---it is a throughput allocation metric.} It describes how Poseidon2 cycles are allocated between STARK (memory-bandwidth-limited) and PoW (compute-limited). $U \approx 67\%$ because 8 of 24 input state elements carry $\mathit{header\_digest}$ rather than ZK data. The PoW cycles provide additional network security as a low-marginal-cost byproduct. The two workloads are complementary: PoW is compute-bound, STARK is memory-bound. They share Poseidon2 cores but bottleneck on different resources, achieving near-perfect utilization.

\textbf{Width-24 efficiency.} Because STARK Merkle throughput is SRAM-bandwidth-limited at ${\sim}2.08$G hash/sec, Width-24 compression (1~perm/hash) delivers the same ZK proof rate as Width-16 sponge (2~perm/hash) while consuming half the Poseidon2 cycles (${\sim}10\%$ vs ${\sim}20\%$ of core capacity). The freed cycles serve PoW. Higher SRAM bandwidth increases ZK proof \emph{economic throughput} (more proofs/sec) but does not change $U$.

\subsubsection{Increasing STARK Throughput}
\label{sec:sram-scaling}

\begin{table}[h]
\centering
\begin{tabular}{@{}lcccc@{}}
\toprule
Memory technology & Bandwidth & $f$ & $U_{\mathrm{avg}}$ ($f \times 67\%$) & Proofs/sec \\
\midrule
SRAM 32\,MB & 200\,GB/s & ${\sim}10\%$ & ${\sim}6.7\%$ & ${\sim}260$ \\
SRAM 64\,MB & 400\,GB/s & ${\sim}20\%$ & ${\sim}13\%$ & ${\sim}520$ \\
HBM3 8\,GB & 1.2\,TB/s & ${\sim}60\%$ & ${\sim}40\%$ & ${\sim}1{,}560$ \\
HBM3E 16\,GB & 2.4\,TB/s & ${\sim}100\%$ & ${\sim}67\%$ & ${\sim}3{,}120$ \\
\bottomrule
\end{tabular}
\caption{$U_{\mathrm{avg}}$ scaling with memory bandwidth.}
\label{tab:memory-scaling}
\end{table}

With HBM, the STARK fraction approaches 100\%, and nearly all Poseidon2 cycles serve STARK computation simultaneously with PoW. Note: this increases ZK proof \emph{economic throughput} but does not change $U$ (which is bounded by $t_0/t = 16/24 \approx 67\%$, the width extension overhead). Higher memory bandwidth cannot overcome the fundamental width ratio cost.

\subsection{Die Area: kHeavyHash vs Poseidon2-PoW}

\subsubsection{kHeavyHash Core}
\begin{Verbatim}[fontsize=\small]
cSHAKE256 hash (x2):        ~80K gates (2x Keccak-f[1600], ~40K each)
64x64 nibble matrix mul:    ~65K gates (integer matmul + XOR)
Control:                      ~5K gates
Total:                      ~150K gates per core
Throughput:                 ~1G hashes/sec per core @ 1GHz

Note: Keccak-f[1600] gate counts range from ~12K (compact/folded) to
~120K (fully pipelined). The ~40K estimate assumes a mid-pipeline
design (4-8 round stages) balancing area and throughput for ASIC mining.
\end{Verbatim}

\subsubsection{Poseidon2-PoW Core (M31, Width 24, Full Pipeline)}
\begin{Verbatim}[fontsize=\small]
S-box circuits:             ~642K gates
  External: 24 x 3K x 8 rounds = 576K
  Internal:  1 x 3K x 22 rounds = 66K
MDS circuits:               ~624K gates
  External: 6 M4 blocks x ~2K x 8 rounds = 96K (shift+add only)
  Internal: 24 x 1K x 22 rounds = 528K
Round constant storage:      ~55K gates (214 constants x 31 bits)
Pipeline registers:          ~108K gates (24 x 31 bits x 29 stages)
Input MUX + output router:   ~1K gates
PoW controller:              ~2K gates (header reg, nonce counter, triple target comparator)
Total:                       ~1.4M gates per core
Throughput:                  ~1G perm/sec -> 3G effective hash/sec (3 tickets) @ 1GHz
\end{Verbatim}

\subsubsection{Chip-Level Comparison}

\begin{table}[h]
\centering
\small
\begin{tabular}{@{}lll@{}}
\toprule
Metric & kHeavyHash ASIC & Poseidon2-PoW (Width 24) \\
\midrule
Core area & ${\sim}150$K gates & ${\sim}1.4$M gates \\
Cores (60M gate die) & ${\sim}380$ (95\% utilized) & ${\sim}21$ (50\% allocated) \\
Throughput per core & ${\sim}1$G/s & ${\sim}1$G perm/s $\to$ 3G eff/s (3 tickets) \\
Total chip hashrate & ${\sim}380$G/s & ${\sim}63$G/s effective \\
ZK proof capability & None & ${\sim}260$ proofs/sec \\
Additional components & None & NTT, SRAM, controller \\
\bottomrule
\end{tabular}
\caption{Chip-level comparison: kHeavyHash vs Poseidon2-PoW.}
\label{tab:chip}
\end{table}

Poseidon2 has ${\sim}6\times$ lower PoW hashrate per die than kHeavyHash. \textbf{This is absorbed by difficulty adjustment}---all miners use the same hash function, so per-miner revenue is determined by hashrate share, not absolute hashrate. The ZK proof capability provides additional revenue unavailable to kHeavyHash miners.

\subsection{M31 vs Goldilocks ASIC Comparison}

\begin{table}[h]
\centering
\begin{tabular}{@{}lll@{}}
\toprule
Metric & Goldilocks ($2^{64}-2^{32}+1$) & M31 ($2^{31}-1$) \\
\midrule
Element size & 64 bits & 31 bits \\
Multiplier gates & ${\sim}3{,}500$ & ${\sim}1{,}000$ \\
Multiplier latency & 2--3 cycles & 1 cycle \\
Poseidon2 width (ext.) & 13 (rate 9, cap 4) & 24 (compression) \\
Hash output & $4 \times 64 = 256$ bits & $8 \times 31 = 248$ bits \\
Cores per die (30M gates) & ${\sim}23$ & ${\sim}21$ \\
STARK ecosystem & Plonky2/Plonky3 & \textbf{Stwo (potential Kaspa choice)} \\
\bottomrule
\end{tabular}
\caption{M31 vs Goldilocks ASIC comparison.}
\label{tab:m31-vs-gold}
\end{table}

\textbf{M31 is the natural choice} if Kaspa adopts Stwo. The smaller multiplier (1/3.5 area) enables higher core density and hashrate per die, while matching Stwo's field arithmetic exactly.

% ============================================================
\section{Trace Grinding Analysis}
\label{app:tracegrinding}

We prove that trace selection in Symbiotic mode provides zero advantage for PoW mining under the PRP assumption on Poseidon2.

\subsection{Assumptions}

\begin{enumerate}
\item \textbf{PRP.} The Poseidon2 permutation $\pi: \mathbb{F}_p^{24} \to \mathbb{F}_p^{24}$ is a pseudorandom permutation. For any input $x$, the output $\pi(x)$ is indistinguishable from uniform over $\mathbb{F}_p^{24}$.
\item \textbf{Fixed tree sizes.} Each Merkle commitment phase $i$ ($i = 0$ for the initial trace commitment, $i = 1, \ldots, m$ for FRI rounds) has $2N_i - 1$ internal nodes, where $N_i$ is determined by the protocol (trace length, blowup factor, FRI folding rate). The values $N_i$ are independent of trace content.
\item \textbf{Fixed header digest.} The header digest $h_H \in \mathbb{F}_p^8$ is fixed at the start of each Merkle commitment phase and constant throughout that phase.
\end{enumerate}

\subsection{Ticket Count Invariance}

Each Poseidon2 permutation in the Merkle tree produces three PoW tickets. The total number of permutations across all STARK phases is:
\[
  P = \sum_{i=0}^{m} (2N_i - 1)
\]
Since each $N_i$ is a protocol parameter independent of the trace $t$:
\[
  \forall\, t_1, t_2: \quad P(t_1) = P(t_2) = P
\]
The miner cannot increase the number of PoW tickets by selecting a different trace.

\subsection{Distribution Invariance}

Under PRP, for any distinct inputs $x_1, \ldots, x_P$ to the permutation, the outputs $\pi(x_1), \ldots, \pi(x_P)$ are jointly pseudorandom. In a Merkle tree, all permutation inputs are distinct with overwhelming probability: two nodes sharing the same input $(n_L, n_R, h_H)$ requires a collision in the 248-bit child outputs, which occurs with probability at most $\binom{P}{2} \cdot 2^{-248}$---negligible for $P \leq 10^7$.

Each permutation produces three PoW tickets. Under PRP, the success event for each permutation (at least one ticket below target $T$) is a Bernoulli trial with parameter:
\[
  q = 1 - (1-p)^3 \approx 3p, \quad p = T / 2^{248}
\]
This parameter depends only on the target $T$, not on the permutation input. Since inter-permutation independence holds (distinct inputs under PRP), the number of successful permutations follows:
\[
  V \sim \mathrm{Binomial}(P,\, q)
\]
Both parameters $(P, q)$ are trace-independent. Therefore, not only the expectation $E[V] = Pq$ but the \emph{entire distribution} of valid tickets is invariant under trace selection. There is no trace for which the variance is smaller (guaranteeing a hit) or larger.

\textbf{Fiat-Shamir cascade.} Trace selection affects FRI round Merkle trees via the Fiat-Shamir challenge dependency on the initial Merkle root. Changing the trace changes all subsequent challenges, folding points, and FRI Merkle trees. However, each FRI tree size $N_i$ is protocol-determined, and PRP ensures each resulting ticket has identical success probability. The argument above extends to all commitment phases.

\subsection{Header Digest Grinding}

The miner can produce different header digests $h_H$ by choosing different parent blocks or transaction sets. With the same trace but a new $h_H$, the entire Merkle tree must be rebuilt (cost: $P$ permutations), producing $P$ new permutation triples. Under PRP, this is functionally equivalent to $P$ pure PoW nonce hashes---identical cost, identical ticket distribution. Moreover, only one $h_H$ can be used for the STARK proof; the remaining attempts produce PoW tickets but discard the STARK computation. Header digest grinding offers no advantage beyond standard nonce grinding.

\subsection{Multi-Trial Grinding}

A miner who computes $k$ distinct traces and selects the one with the most valid PoW tickets:

\textbf{Cost:} $k \times (C_{\mathrm{NTT}} + C_{\mathrm{trace}} + P)$ permutations, where $C_{\mathrm{NTT}}$ and $C_{\mathrm{trace}}$ are the NTT and trace generation costs (counted conservatively as zero in the comparison below).

\textbf{Benefit:} $\max(V_1, \ldots, V_k)$ where each $V_i \sim \mathrm{Binomial}(P, q)$ independently.

For the same $k \times P$ Poseidon2 permutations in pure PoW mode, all tickets are valid (none discarded), yielding $V_{\mathrm{PoW}} \sim \mathrm{Binomial}(kP, q)$.

By linearity, $E[V_{\mathrm{PoW}}] = kPq$. The best-of-$k$ selection gives $E[\max(V_1, \ldots, V_k)] \leq Pq + O(\sqrt{\log k \cdot Pq(1-q)})$. For any $k \geq 2$:
\[
  E[\max(V_1, \ldots, V_k)] < kPq = E[V_{\mathrm{PoW}}]
\]
Multi-trial grinding is strictly dominated by pure PoW. Including the NTT and trace generation overhead (omitted above) makes the comparison strictly worse for grinding.

\subsection{Merkle Tree Feedback Structure}

In Width-24 compression, the Merkle parent output $S[0..7]$ becomes an input to the next tree level, and $h_H$ occupies $S[16..23]$ at every level. This creates structured, non-i.i.d.\ inputs to successive permutations. Under PRP, the permutation's output distribution is uniform regardless of input structure. The full 30-round Poseidon2 (8~external + 22~internal) provides complete diffusion across all 24 state elements. Any weakness in PRP for structured inputs would constitute a break of Poseidon2 itself---the same assumption underlying the PoW security analysis (\S\ref{sec:width24sec}). \qed

\subsection{Triple-Ticket Independence}
\label{app:triple-ticket}

The three PoW tickets $\mathit{pow\_ticket}_0 = S[0..7]$, $\mathit{pow\_ticket}_1 = S[8..15]$, and $\mathit{pow\_ticket}_2 = S[16..23]$ are outputs of the same Poseidon2 permutation and therefore deterministically linked. We show that under PRP, this linkage carries no exploitable statistical correlation.

\begin{proposition}
Under the PRP assumption on Poseidon2, $\mathit{pow\_ticket}_0$, $\mathit{pow\_ticket}_1$, and $\mathit{pow\_ticket}_2$ are mutually independent.
\end{proposition}

\begin{proof}
Let $\pi: \mathbb{F}_p^{24} \to \mathbb{F}_p^{24}$ be a PRP. For any fixed input $x \in \mathbb{F}_p^{24}$, the output $\pi(x)$ is computationally indistinguishable from a uniform sample over $\mathbb{F}_p^{24}$.

Partition $\mathbb{F}_p^{24} = \mathbb{F}_p^8 \times \mathbb{F}_p^8 \times \mathbb{F}_p^8$ as $(A, B, C)$ where $A = S[0..7]$, $B = S[8..15]$, $C = S[16..23]$. If $(A, B, C)$ is uniform over $\mathbb{F}_p^{24}$, then $A$, $B$, $C$ are mutually independent, each uniform over $\mathbb{F}_p^8$. This is a standard property of product probability spaces: the uniform distribution on a product space implies independence of coordinate projections.

Therefore:
\begin{align*}
P(A < T) &= p = T/2^{248} \\
P(B < T) &= p \\
P(C < T) &= p \\
P(A < T \;\wedge\; B < T \;\wedge\; C < T) &= p^3 \\
P(A < T \;\vee\; B < T \;\vee\; C < T) &= 1 - (1-p)^3 = 3p - 3p^2 + p^3
\end{align*}

The quantity $q = 1 - (1-p)^3$ used in \S\ref{sec:pow-dist} and Appendix~\ref{app:tracegrinding} is exact under PRP, not an approximation.
\end{proof}

\textbf{Implication for mining.} A miner who observes any one ticket gains no information about whether the other two are below target. The only way to evaluate all tickets is to compute the full Poseidon2 permutation---which already produces all three simultaneously. There is no early-termination optimization. In Symbiotic mode, $\mathit{pow\_ticket}_0 = \mathit{merkle\_parent}$: reading it for PoW comparison does not modify the value used by the STARK Merkle tree.

\textbf{Distinguisher reduction.} Any statistical test $\mathcal{T}$ that detects correlation among $S[0..7]$, $S[8..15]$, and $S[16..23]$ across multiple Poseidon2 evaluations can be converted into a PRP distinguisher: run $\mathcal{T}$ on $\pi$ vs a truly random permutation $\rho$, and distinguish based on whether the test detects correlation. The advantage of $\mathcal{T}$ as a correlator equals its advantage as a PRP distinguisher. Under the PRP assumption, no such efficient $\mathcal{T}$ exists. \qed

% ============================================================
\begin{thebibliography}{10}

\bibitem{ball2017}
M.~Ball, A.~Rosen, M.~Sabin, and P.~N.~Vasudevan,
``Proofs of Useful Work,''
\emph{IACR Cryptology ePrint Archive}, 2017/203, 2017.
\url{https://eprint.iacr.org/2017/203}

\bibitem{poseidon}
L.~Grassi, D.~Khovratovich, C.~Rechberger, A.~Roy, and M.~Schofnegger,
``Poseidon: A New Hash Function for Zero-Knowledge Proof Systems,''
in \emph{USENIX Security Symposium}, 2021.
\url{https://eprint.iacr.org/2019/458}

\bibitem{poseidon2}
L.~Grassi, D.~Khovratovich, and M.~Schofnegger,
``Poseidon2: A Faster Version of the Poseidon Hash Function,''
\emph{IACR Cryptology ePrint Archive}, 2023/323, 2023.
\url{https://eprint.iacr.org/2023/323}

\bibitem{stwo}
StarkWare,
``Stwo: A STARK Prover.''
\url{https://github.com/starkware-libs/stwo}

\bibitem{dagknight}
Y.~Sompolinsky and M.~Sutton,
``The DAG KNIGHT Protocol: A Parameterless Generalization of Nakamoto Consensus,''
\emph{IACR Cryptology ePrint Archive}, 2022/1494, 2022.
\url{https://eprint.iacr.org/2022/1494}

\bibitem{kaspa}
Kaspa,
``kHeavyHash Specification.''
\url{https://github.com/kaspanet/rusty-kaspa}

\bibitem{ofelimos}
M.~Fitzi, A.~Kiayias, G.~Panagiotakos, and A.~Russell,
``Ofelimos: Combinatorial Optimization via Proof-of-Useful-Work,''
in \emph{Crypto 2022}.
\url{https://eprint.iacr.org/2021/1379}

\bibitem{komargodski2025}
I.~Komargodski and O.~Weinstein,
``Proofs of Useful Work from Arbitrary Matrix Multiplication,''
\emph{IACR Cryptology ePrint Archive}, 2025/685, 2025.
\url{https://eprint.iacr.org/2025/685}

\bibitem{baron2025}
Y.~Bar-On, I.~Komargodski, and O.~Weinstein,
``Proof of Work With External Utilities,''
arXiv:2505.21685, 2025.
\url{https://arxiv.org/abs/2505.21685}

\bibitem{plonky3}
Plonky3,
``A Toolkit for Polynomial IOPs,''
\texttt{poseidon2/src/round\_numbers.rs}, \texttt{mersenne-31/src/poseidon2.rs}.
\url{https://github.com/Plonky3/Plonky3} (accessed 2026-02-16).

\end{thebibliography}

\end{document}
