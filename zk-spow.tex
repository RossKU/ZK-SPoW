\documentclass[11pt,a4paper]{article}

% --- Packages ---
\usepackage[margin=1in]{geometry}
\usepackage{amsmath,amssymb,amsthm}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{array}
\usepackage{graphicx}
\usepackage{fancyvrb}
\usepackage[breaklinks=true]{hyperref}
\usepackage{url}
\urlstyle{same}
\usepackage{microtype}
\usepackage{parskip}

% --- Theorem environments ---
\newtheorem{definition}{Definition}
\newtheorem{proposition}{Proposition}

% --- Title ---
\title{\textbf{ZK-SPoW: ZK-Symbiotic Proof of Work for Kaspa}}
\author{Anonymous\thanks{Preprint. Work in progress.}}
\date{February 2026 --- Version 0.2 (Draft)}

\begin{document}
\maketitle

% ============================================================
\begin{abstract}
We propose replacing Kaspa's kHeavyHash proof-of-work function with a Width-24 Poseidon2 compression function over the Mersenne field $\mathbb{F}_p$, $p = 2^{31}-1$ (M31). Traditional Proof of Useful Work (PoUW) attempts to make PoW computation produce useful results---a direction that Ball et al.~\cite{ball2017} show requires careful construction with practical deployment constraints. ZK-SPoW (ZK-Symbiotic Proof of Work) inverts this relationship: useful ZK computation (STARK Merkle hashing) naturally produces PoW tickets as a mathematical byproduct. By operating Poseidon2 in compression function mode with width~24, every STARK Merkle hash accepts a child pair plus block header digest as input and simultaneously outputs a parent node advancing the ZK proof and two PoW tickets---from a single permutation. The miner does not choose the PoW input; the STARK computation determines it. This unification carries a cost of $U = t_0/t = 16/24 \approx 67\%$---the remaining 33\% of each permutation serves PoW integration. In return, the same hardware performs both network security and useful computation with zero switching overhead. Width-24 requires a Kaspa-specific Poseidon2 verifier (Stwo-Kaspa), an incremental cost within the kHeavyHash $\to$ Poseidon2 hard fork. Security claims assume final Poseidon2 production parameters (\S\ref{sec:open}).
\end{abstract}

% ============================================================
\section{Introduction}
\label{sec:intro}

\subsection{The PoW Energy Problem}

Kaspa uses kHeavyHash---cSHAKE256 (Keccak/SHA-3 family) composed with a $64\times64$ matrix multiplication over 4-bit nibbles---for proof of work. Like all traditional PoW schemes, the computational work produces no output beyond network security. The entire energy expenditure is justified solely by the security guarantees it provides.

\subsection{The PoUW Paradox and Its Inversion}
\label{sec:pouw-paradox}

Ball et al.~\cite{ball2017} formalize \textbf{Proof of Useful Work (PoUW)} as a PoW scheme where the mining computation simultaneously produces useful output. Their strict definition requires:
\begin{enumerate}
\item The PoW computation itself produces useful output
\item The verifier can confirm the usefulness
\item The useful output is bound to the PoW evidence
\end{enumerate}

The fundamental tension: PoW requires random exploration (nonce grinding), while useful computation requires specific, deterministic work. Prior PoUW constructions \cite{ball2017,ofelimos,komargodski2025,baron2025} achieve provable security for specific problem classes, but require pre-hashing, SNARGs, or domain-specific verification that limits practical deployment in high-throughput blockchains (100~BPS).

\textbf{ZK-SPoW inverts this relationship.} Instead of making PoW results useful, we start from useful computation (STARK proof generation) and observe that PoW tickets emerge as a natural mathematical byproduct:

\begin{quote}
\textbf{Conventional PoUW:} PoW computation $\to$ try to make results useful $\to$ fundamental constraints~\cite{ball2017}

\textbf{ZK-SPoW:} Useful ZK computation $\to$ PoW tickets as mathematical byproduct $\to$ no contradiction
\end{quote}

\begin{definition}[ZK-SPoW]
A PoW scheme where the hash function is a width-extended Poseidon2 compression function operating on STARK Merkle data, such that every permutation simultaneously advances a ZK proof and produces PoW tickets.
\end{definition}

The mechanism: STARK proof generation requires millions of Merkle hashes. Each Width-24 Poseidon2 Merkle hash takes $(\mathit{left\_child}, \mathit{right\_child}, \mathit{header\_digest})$ as input and produces $(\mathit{merkle\_parent}, \mathit{pow\_ticket}_1, \mathit{pow\_ticket}_2)$ as output. The $\mathit{merkle\_parent}$ advances the ZK proof; the PoW tickets are checked against the difficulty target. The miner cannot choose the Merkle inputs---they are determined by the STARK computation. The ``random exploration'' required for PoW occurs naturally because STARK Merkle tree hashes are pseudorandom from the miner's perspective.

\begin{definition}[Usefulness]
\begin{itemize}
\item $U = t_0/t = 16/24 \approx 67\%$ when the ASIC is executing ZK proof computation (Symbiotic mode)
\item $U = 0\%$ when the ASIC is grinding nonces without concurrent ZK computation (Pure PoW mode)
\end{itemize}
The 33\% overhead per permutation is the cost of PoW integration: 8 of 24 state elements serve $\mathit{header\_digest}$ input and dual PoW ticket output, rather than ZK computation. This is the inherent price of unifying ZK and PoW into a single permutation---not waste, but the cost of symbiosis.

$U$ is a per-permutation metric. The time-averaged usefulness across all Poseidon2 cycles is $U_{\mathrm{avg}} = f_{\mathrm{sym}} \times U$, where $f_{\mathrm{sym}}$ is the fraction of cycles executing STARK Merkle hashes (determined by memory bandwidth; see \S\ref{sec:bottleneck} and \S\ref{sec:sram}).
\end{definition}

If a PoW solution is found mid-proof, the block is submitted without interrupting ZK computation. When no ZK demand exists, the ASIC reverts to pure PoW ($U = 0\%$), identical to any conventional miner.

\subsection{Stwo and Poseidon2}

Kaspa is evaluating StarkWare's \textbf{Stwo}~\cite{stwo} as a potential STARK backend for verifiable programs (vProgs). Stwo operates over the Mersenne field M31 and uses \textbf{Poseidon2}~\cite{poseidon2} as its internal hash function for Merkle tree commitments and Fiat-Shamir challenges.

This creates a unique opportunity: if the PoW hash function is also Poseidon2 over M31, then the mining ASIC's primary computational element---the Poseidon2 pipeline---can serve both STARK proof generation and PoW mining. The cost is a Poseidon2 width extension from 16 to 24 elements with increased round count ($+44$--$105\%$ core area, ${\sim}+22$--$50\%$ die area depending on implementation; see \S\ref{sec:width}).

\textbf{Stwo-Kaspa verifier.} Standard Stwo uses Width-16 Poseidon2 in sponge mode. Width-24 Poseidon2 is a different cryptographic function (different MDS matrix, different round count, different S-box count per external round). ZK-SPoW therefore requires a Kaspa-specific verifier supporting Width-24 compression---a parameter change within Poseidon2's design framework~\cite{poseidon2}, not a new cryptographic construction. Since the kHeavyHash $\to$ Poseidon2 transition already requires a hard fork with full-node verifier updates, the Width-24 adaptation is an incremental cost.

\subsection{Contributions}
\label{sec:contributions}

\begin{enumerate}
\item \textbf{PoUW paradox inversion.} We formalize ZK-Symbiotic Proof of Work, a construction where useful ZK computation (STARK Merkle hashing) naturally produces PoW tickets as a cryptographically bound byproduct---inverting the traditional PoUW direction explored by Ball et al.~\cite{ball2017}, Ofelimos~\cite{ofelimos}, and Komargodski et al.~\cite{komargodski2025,baron2025} (\S\ref{sec:pouw-paradox}).

\item \textbf{Width-24 Poseidon2 parameterization.} We specify Width-24 Poseidon2 over M31 in compression function mode and verify its security parameters: $R_p = 22$ internal rounds for 128-bit security with $D = 5$, confirmed via Plonky3's verified round number computation~\cite{plonky3}. The per-ticket S-box cost decreases by 25\% compared to Width-16 despite 51\% more S-box operations per permutation, due to the dual-ticket structure (\S\ref{sec:width24sec}).

\item \textbf{Complementary bottleneck architecture.} We demonstrate that PoW mining (compute-bound) and STARK proof generation (memory-bound) can share Poseidon2 hardware with zero-cycle switching overhead, and provide gate-level ASIC architecture analysis for a 7\,nm implementation (\S\ref{sec:modes}, Appendix~\ref{app:asic}).
\end{enumerate}

% ============================================================
\section{Notation and Definitions}
\label{sec:notation}

\begin{table}[h]
\centering
\begin{tabular}{@{}ll@{}}
\toprule
Symbol & Definition \\
\midrule
$\mathbb{F}_p$ & Finite field, $p = 2^{31}-1$ (Mersenne prime M31) \\
$\mathrm{Poseidon2}_\pi$ & Poseidon2 permutation over $\mathbb{F}_p^t$ \\
$t$ & State width (number of field elements in permutation) \\
$r$ & Rate: number of input/output elements (sponge mode) \\
$c$ & Capacity: security parameter (sponge mode; hidden elements) \\
$n$ & Hash output size in field elements ($n = 8$, giving 248 bits) \\
$H$ & Block header (all consensus fields; see \S\ref{sec:block}) \\
$h_H$ & Header digest: $\mathrm{PoseidonSponge}(H \text{ excluding nonce}) \in \mathbb{F}_p^k$ \\
$k$ & Header digest element count ($k = 8$ for symmetric I/O) \\
$(v_1, v_2)$ & Nonce: $v_1, v_2 \in \mathbb{F}_p^8$ \\
$T$ & Target $\in \mathbb{F}_p^8$ (difficulty-adjusted) \\
$S$ & Poseidon2 state after permutation, $S \in \mathbb{F}_p^t$ \\
\bottomrule
\end{tabular}
\caption{Notation summary.}
\label{tab:notation}
\end{table}

\textbf{Stwo baseline parameters} (confirmed from source code~\cite{stwo}):

\begin{table}[h]
\centering
\begin{tabular}{@{}ll@{}}
\toprule
Parameter & Value \\
\midrule
Field & M31, $p = 2^{31}-1$ \\
Hash output & 8 elements = 248 bits \\
Standard width & $t_0 = 16$ (sponge mode: rate 8, capacity 8) \\
External rounds $R_f$ & 8 (4 + 4) \\
Internal rounds $R_p$ & 14 \\
S-box exponent & $\alpha = 5$ \\
Merkle hash & 2 permutations per node (sponge: absorb left[8], absorb right[8]) \\
Commitment hash & Blake2s (base layer), Poseidon2 (recursive proofs) \\
\bottomrule
\end{tabular}
\caption{Stwo baseline Poseidon2 parameters.}
\label{tab:stwo-baseline}
\end{table}

\textbf{Note:} All security claims in this paper assume final production round constants. The current Stwo implementation uses placeholder values (\texttt{EXTERNAL\_ROUND\_CONSTS} and \texttt{INTERNAL\_ROUND\_CONSTS} uniformly set to \texttt{1234}; see \S\ref{sec:open}).

% ============================================================
\section{Protocol Specification}
\label{sec:protocol}

\subsection{PoW Function Replacement}
\label{sec:pow-replacement}

\textbf{Current (kHeavyHash):}
\begin{Verbatim}[fontsize=\small]
pow_hash = cSHAKE256(M * cSHAKE256(H || nonce) XOR cSHAKE256(H || nonce))
valid iff pow_hash < target
\end{Verbatim}
where $M$ is a $64\times64$ matrix (generated from header, full-rank over nibbles), nonce is 8 bytes.

\textbf{Proposed (Poseidon2-PoW):}
\begin{Verbatim}[fontsize=\small]
h_H = PoseidonSponge(H excluding nonce)       // amortized pre-hash (8 M31 elements)
S   = Poseidon2_pi(v1 || v2 || h_H)           // single permutation, width 24
pow_hash1 = (S[8], S[9], ..., S[15])           // 8 M31 elements = 248 bits
pow_hash2 = (S[16], S[17], ..., S[23])         // 8 M31 elements = 248 bits
valid iff pow_hash1 < target OR pow_hash2 < target
\end{Verbatim}
where $(v_1, v_2)$ are 8 M31 elements each (64 bytes total nonce). The permutation operates in \textbf{compression function mode}---all 24 input elements are visible (no hidden capacity). This differs from Stwo's standard sponge mode (width 16, rate 8, capacity 8) but is a recommended Poseidon2 usage mode~\cite{poseidon2}. Each permutation produces \textbf{two PoW tickets}, doubling the effective hashrate per permutation. The comparison $\mathit{pow\_hash} < \mathit{target}$ interprets both as 248-bit unsigned integers via big-endian concatenation of 8 M31 elements, each zero-padded to 31 bits.

\textbf{Verification cost:} One Poseidon2 permutation (width 24) + two target comparisons + one header pre-hash (amortized).

\textbf{Standard PoW structure.} ZK-SPoW is conventional hash-based PoW: miners explore a nonce space by computing Poseidon2 permutations and comparing outputs against a difficulty target, identically to Nakamoto-style PoW. The ZK component (Symbiotic mode, \S\ref{sec:symbiotic}) is an optional revenue source sharing the same hardware---it does not modify the PoW function, security model, or difficulty adjustment. When no ZK demand exists, the ASIC reverts to conventional PoW mining (\S\ref{sec:pure-pow}) with identical security guarantees.

\subsection{Poseidon2 Width Extension}
\label{sec:width}

The core design change is extending the Poseidon2 permutation width to accommodate header digest as an additional input, and switching from sponge mode to compression function mode.

\subsubsection{Stwo Baseline}

Stwo's Poseidon2 operates in \textbf{sponge mode} with width 16:
\begin{Verbatim}[fontsize=\small]
Width t0 = 16
Rate  r  = 8    <- absorbs 8 elements per permutation
Capacity c = 8  <- hidden elements (security)
\end{Verbatim}

For Merkle tree commitments, each node hash requires \textbf{two sponge absorptions}:
\begin{Verbatim}[fontsize=\small]
Absorb left_child[8]  -> Permute -> (state updated)
Absorb right_child[8] -> Permute -> Squeeze output[8]
Total: 2 permutations per Merkle hash
\end{Verbatim}

\subsubsection{Design Alternatives}
\label{sec:design-alt}

Three approaches to integrate header digest into the Merkle hash:

\begin{table}[h]
\centering
\small
\begin{tabular}{@{}lllcccc@{}}
\toprule
Design & Width & Mode & Perm/hash & PoW tickets & Core $\Delta$ & Die $\Delta$ \\
\midrule
A: 3rd absorb & 16 & Sponge & 3 (+50\%) & 1 & 0\% & 0\% \\
B: Width 20 & 20 & Compression & 1 & 1 (+4 wasted) & +22\% & ${\sim}$+11\% \\
\textbf{C: Width 24} & \textbf{24} & \textbf{Compression} & \textbf{1} & \textbf{2} & \textbf{+44--105\%} & $\mathbf{{\sim}\text{+22--50\%}}$ \\
\bottomrule
\end{tabular}
\caption{Design alternatives for header digest integration.}
\label{tab:designs}
\end{table}

\textbf{Design~A:} No Poseidon2 modification. Standard width-16 sponge with 3~absorptions (left, right, header). 3~permutations per Merkle hash; ZK throughput is unaffected under SRAM-bandwidth-bound operation (\S\ref{sec:bottleneck}).

\textbf{Design~B:} Extend to width~20 with $\mathit{header\_digest}[4]$. Compression function mode, 1~permutation per hash. But 4~output elements are unused (asymmetric $8{+}8{+}4$ I/O).

\textbf{Design~C (selected):} Extend to width~24 with $\mathit{header\_digest}[8]$. Symmetric $8{+}8{+}8$ I/O---all output elements are useful. \textbf{2~PoW tickets per permutation} ($S[8..15]$ and $S[16..23]$), yielding $+67\%$ effective hashrate over Design~B despite 17\% fewer cores. Header digest security doubles (248 vs 124 bits). Width~24 is within the Poseidon2 paper's analyzed parameter range~\cite{poseidon2}. \textbf{ZK throughput is unaffected}: STARK Merkle hashing is SRAM-bandwidth-bound regardless of core width (see \S\ref{sec:bottleneck}). The width extension cost manifests as $U = 16/24 \approx 67\%$ (\S\ref{sec:pouw-paradox}). \textbf{Requires Stwo-Kaspa verifier} supporting Width-24 compression function mode.

\textbf{Design~A vs~C tradeoff.} Under current SRAM bandwidth (${\sim}200$~GB/s; \S\ref{sec:sram}), Design~A's smaller Width-16 cores yield more cores per die and higher total PoW hashrate despite 3~perm/hash. However, Design~A's $3\times$ permutation cost per STARK hash becomes a bottleneck as memory bandwidth increases: at HBM-class bandwidth ($>1$~TB/s), STARK saturates Design~A's Poseidon2 capacity, leaving minimal room for PoW. Design~C's 1~perm/hash scales linearly with bandwidth, maintaining full PoW throughput at any memory tier. Design~C also simplifies scheduling (each permutation is stateless, vs sponge state tracking across 3~absorptions in Design~A). The tradeoff: Design~A uses well-analyzed Width-16 parameters with no Stwo modification; Design~C requires a Width-24 Stwo-Kaspa verifier (\S\ref{sec:open}) but is future-proof for higher-bandwidth memory architectures.

\subsubsection{Proposed Extension (Design~C)}
\label{sec:design-c}

\begin{Verbatim}[fontsize=\small]
Standard Stwo:    Width t0 = 16,  Sponge (rate 8, capacity 8)
Proposed ZK-SPoW: Width t  = 24,  Compression function (all 24 visible)
\end{Verbatim}

\textbf{Impact on Poseidon2 internals:}

\begin{table}[h]
\centering
\small
\begin{tabular}{@{}llll@{}}
\toprule
Component & Width 16 (standard) & Width 24 (proposed) & Change \\
\midrule
External MDS & 4 M4 blocks & 6 M4 blocks & +50\% additions \\
Internal MDS & 16 multiplications & 24 multiplications & +50\% mult. \\
S-box (external) & 16 per round & 24 per round & +50\% \\
S-box (internal) & 1 per round & 1 per round & unchanged \\
Internal rounds $R_p$ & 14 & 22 & +57\% \\
Total rounds & 22 ($8{+}14$) & 30 ($8{+}22$) & +36\% \\
S-box operations & 142 & 214 & +51\% \\
State registers & $16 \times 31 = 496$ bits & $24 \times 31 = 744$ bits & +50\% \\
\bottomrule
\end{tabular}
\caption{Poseidon2 internals: Width-16 vs Width-24.}
\label{tab:internals}
\end{table}

Internal round MDS scales as $O(t)$, not $O(t^2)$, because the sparse MDS structure (diagonal $+$ rank-1) requires only $t$~multiplications per round. This makes the width extension significantly cheaper than for standard Poseidon.

\textbf{Core area overhead: $+44\%$ (datapath width) to ${\sim}+105\%$ (fully pipelined).} The datapath widens by 50\% ($24/16$), and Width-24 requires $R_p = 22$ internal rounds vs Width-16's $R_p = 14$ (\S\ref{sec:width24sec}), adding $+36\%$ pipeline depth (30 vs 22 total rounds). In an iterative (round-reuse) design, core area increases by ${\sim}+50\%$ (width only) with 36\% more cycles per hash. In a fully pipelined design, core area approximately doubles. Total die area impact: ${\sim}+22\%$ to ${\sim}+50\%$ depending on implementation (Poseidon2 is 50\% of die; see Appendix~\ref{app:asic}). The 2-ticket property yields $+67\%$ effective hashrate and S-box cost per PoW ticket \emph{decreases} by 25\% (107 vs 142), partially offsetting the core count reduction. The usefulness cost is $U = t_0/t = 16/24 \approx 67\%$---the 33\% overhead per permutation serves PoW integration, not ZK computation.

\subsubsection{Compression Function vs Sponge}

Standard Stwo uses sponge mode with 8 hidden capacity elements. This proposal uses \textbf{compression function mode} where all 24 state elements are visible.

\begin{table}[h]
\centering
\begin{tabular}{@{}lll@{}}
\toprule
Property & Sponge (Stwo standard) & Compression (ZK-SPoW) \\
\midrule
Hidden state & 8 capacity elements & None (all visible) \\
Security model & Indifferentiability & Collision/preimage of $\pi$ \\
Perm.\ per Merkle hash & 2 & \textbf{1} \\
Width & 16 & 24 \\
PoW tickets per hash & 0 & \textbf{2} \\
\bottomrule
\end{tabular}
\caption{Sponge vs compression function mode.}
\label{tab:sponge-vs-comp}
\end{table}

Both modes are established Poseidon2 usage modes~\cite{poseidon2}. The Poseidon2 paper recommends compression function mode for Merkle trees, noting up to $5\times$ efficiency over sponge mode in compute-bound settings. On ASIC implementations, STARK Merkle throughput is typically SRAM-bandwidth-bound (see \S\ref{sec:sram}), so the per-permutation efficiency gain manifests as more Poseidon2 cycles available for PoW rather than faster ZK proof generation. Width~24 is within the paper's analyzed parameter range~\cite{poseidon2,plonky3}.

\subsection{I/O Mapping}
\label{sec:io}

For a single Poseidon2 permutation with state $S \in \mathbb{F}_p^{24}$ (compression function mode):

\begin{Verbatim}[fontsize=\small]
INPUT (24 = 8+8+8, all visible):
  S[0..7]    <- left_child      8 M31 elements (248 bits)
  S[8..15]   <- right_child     8 M31 elements (248 bits)
  S[16..23]  <- header_digest   8 M31 elements (248 bits)

          [ Poseidon2 permutation (t = 24) ]
          [ R_f = 8 external + R_p = 22 int ]

OUTPUT (24 = 8+8+8, all visible):
  S[0..7]    -> merkle_node     STARK Merkle parent node (useful)
  S[8..15]   -> pow_hash1       PoW ticket 1 (248 bits)
  S[16..23]  -> pow_hash2       PoW ticket 2 (248 bits)
\end{Verbatim}

Symmetric $8{+}8{+}8$ I/O with no unused output elements. No capacity elements---compression function mode exposes all state elements. Security relies on the Poseidon2 permutation's collision resistance and PRP properties (see \S\ref{sec:sponge-comp}).

\textbf{Note on full diffusion:} The Poseidon2 permutation mixes all 24 state elements through its MDS matrix every round. All output elements are functions of all input elements---there is no structural separation between ``Merkle'' and ``PoW'' outputs. The $8{+}8{+}8$ labeling is a convention for reading the output, not a property of the permutation.

\textbf{Dual-use property:}

\begin{table}[h]
\centering
\small
\begin{tabular}{@{}lllllll@{}}
\toprule
Mode & $S[0..7]_{\mathrm{in}}$ & $S[8..15]_{\mathrm{in}}$ & $S[16..23]_{\mathrm{in}}$ & $S[0..7]_{\mathrm{out}}$ & $S[8..15]_{\mathrm{out}}$ & $S[16..23]_{\mathrm{out}}$ \\
\midrule
Symbiotic & left child & right child & $h_H$ & merkle parent & PoW ticket$_1$ & PoW ticket$_2$ \\
Pure PoW & $v_1$ & $v_2$ & $h_H$ & (discarded) & PoW ticket$_1$ & PoW ticket$_2$ \\
\bottomrule
\end{tabular}
\caption{Dual-use I/O mapping.}
\label{tab:dual-use}
\end{table}

The same Poseidon2 hardware computes both modes. Only the input source for $S[0..15]$ differs (SRAM Merkle data vs random nonces). $S[16..23]$ is always $h_H$. \textbf{Each permutation produces 2~PoW tickets}, doubling effective hashrate.

\subsection{Block Structure}
\label{sec:block}

\textbf{Proposed header} (change from current Kaspa in bold):

\begin{Verbatim}[fontsize=\small]
Header {
  version:                  u16
  parents_by_level:         [[Hash]]       // DAGKnight multi-level parents
  hash_merkle_root:         Hash           // transaction Merkle root
  accepted_id_merkle_root:  Hash
  utxo_commitment:          Hash
  timestamp:                u64            // milliseconds
  bits:                     u32            // difficulty target
  nonce:                    [F_p; 16]      // **64 bytes (currently u64 = 8 bytes)**
  daa_score:                u64
  blue_work:                BlueWorkType
  blue_score:               u64
  pruning_point:            Hash
}
\end{Verbatim}

The only structural change is the nonce expansion from \texttt{u64} (8 bytes) to \texttt{[F\_p; 16]} (64 bytes, +56~bytes per block, ${\sim}0.04\%$ of 125~KB). The nonce maps to Poseidon2 input positions $S[0..15]$ as $(v_1, v_2)$, each 8~M31 elements.

\begin{table}[h]
\centering
\begin{tabular}{@{}lll@{}}
\toprule
 & kHeavyHash (current) & Poseidon2-PoW (proposed) \\
\midrule
Nonce & \texttt{u64} (8 bytes) & \texttt{[F\_p; 16]} (64 bytes) \\
PoW function & kHeavyHash $\to$ 256-bit & Poseidon2 Width-24 $\to$ 248-bit \\
Block hash & Blake2b-256 $\to$ 256-bit & Blake2b-256 $\to$ 256-bit (\textbf{unchanged}) \\
\bottomrule
\end{tabular}
\caption{Block structure comparison.}
\label{tab:block}
\end{table}

\textbf{Block hash vs PoW hash.} Kaspa computes block identity and PoW with separate hash functions. The block hash (Blake2b-256 over the full serialized header including nonce) provides DAG references and block identification---unchanged by this proposal. Only the PoW function is replaced.

\textbf{STARK proofs are NOT included in the block.} They are submitted as independent transactions in the mempool, providing economic value to the ZK ecosystem (vProgs fees). This eliminates the +3--5~MB/s bandwidth overhead that would result from mandatory per-block STARK proofs at 100~BPS.

\subsection{Header Digest Collision Resistance}

The header digest $h_H$ compresses the block header (excluding nonce) into $k$ field elements. If $k$ is too small, an attacker can find two headers $H_A \neq H_B$ with identical $h_H$, allowing PoW solutions to be transplanted between conflicting blocks.

\begin{table}[h]
\centering
\begin{tabular}{@{}cccc@{}}
\toprule
$k$ (elements) & Bits & Birthday bound & Security \\
\midrule
1 & 31 & $2^{15} \approx 32$K & INSECURE \\
2 & 62 & $2^{31} \approx 2 \times 10^9$ & INSECURE \\
4 & 124 & $2^{62} \approx 4.6 \times 10^{18}$ & SECURE \\
8 & 248 & $2^{124}$ & Conservative but justified \\
\bottomrule
\end{tabular}
\caption{Header digest collision resistance by element count.}
\label{tab:collision}
\end{table}

\textbf{Minimum: $k = 4$} (124-bit collision resistance). We choose $\mathbf{k = 8}$ (248-bit, matching PoW hash size) to enable symmetric $8{+}8{+}8$ I/O and 2~PoW tickets per permutation. Width extension: $t = 16 + 8 = 24$.

% ============================================================
\section{Operating Modes}
\label{sec:modes}

\subsection{Symbiotic Mode (Stwo Prover Active)}
\label{sec:symbiotic}

When ZK proof demand exists, the ASIC runs the Stwo prover. The STARK proof generation pipeline:

\begin{Verbatim}[fontsize=\small]
1. Trace generation       -> circuit evaluation
2. NTT (LDE)              -> polynomial domain extension
3. Merkle tree            -> Poseidon2 hashing (PoW tickets appear here)
4. Fiat-Shamir challenge  -> derived from Merkle root
5. FRI rounds             -> folding + commitment
\end{Verbatim}

At step~3, every Merkle hash is:
\begin{Verbatim}[fontsize=\small]
S = Poseidon2_pi(n_L || n_R || h_H)   // width 24, compression function
merkle_parent = S[0..7]     <- advances STARK proof (useful)
pow_ticket1   = S[8..15]    <- checked against PoW target (security)
pow_ticket2   = S[16..23]   <- checked against PoW target (security)
if pow_ticket1 < target OR pow_ticket2 < target -> BLOCK FOUND
\end{Verbatim}

Every Poseidon2 invocation in the STARK computation simultaneously: \textbf{(a)}~advances the ZK proof (economic value---the useful work that drives the permutation), and \textbf{(b)}~produces PoW tickets (network security---mathematical byproduct of the same permutation).

$U = t_0/t = 16/24 \approx 67\%$. The 33\% usefulness gap is the width extension overhead: 8 of 24 state elements per permutation serve PoW ($\mathit{header\_digest}$ input, dual ticket output) rather than ZK. There is no ``ZK only'' mode---every Width-24 permutation produces PoW tickets, regardless of input.

\textbf{Header freshness.} A STARK proof spans multiple Merkle commitment phases---typically $O(10)$ phases---and takes seconds to complete. The $\mathit{header\_digest}$ is fixed per Merkle tree phase; each phase completes within one block interval ($<10$\,ms at ${\sim}2$G hash/sec). Between phases, the $\mathit{header\_digest}$ register updates to the current block. In DAGKnight's DAG structure~\cite{dagknight}, blocks referencing slightly stale headers remain acceptable---parallel block production is normal at 100~BPS.

\subsection{Pure PoW Mode (No ZK Demand)}
\label{sec:pure-pow}

When no ZK proofs are requested:
\begin{Verbatim}[fontsize=\small]
loop:
  v1 = next_nonce_1()
  v2 = next_nonce_2()
  S = Poseidon2_pi(v1 || v2 || h_H)   // width 24, compression function
  if S[8..15] < target OR S[16..23] < target -> BLOCK FOUND
\end{Verbatim}

$U = 0\%$. No ZK proof is being computed. The ASIC provides network security only.

\subsection{Linear Mode Transition}

\begin{Verbatim}[fontsize=\small]
+-- Poseidon2 Pipeline (always 100% utilized) ---------+
|                                                       |
|  Input MUX (per-cycle decision):                      |
|    SRAM data ready  -> STARK Merkle hash (Symbiotic)  |
|    SRAM not ready   -> PoW nonce hash    (PoW)        |
|                                                       |
|  Switching cost: 0 cycles (combinational MUX, ~300 G) |
|  Hashrate: invariant across all modes                 |
+-------------------------------------------------------+
\end{Verbatim}

The transition between Symbiotic and Pure PoW is \textbf{per-cycle and linear}, not a discrete mode switch.

\subsection{Hashrate Invariance}

\begin{proposition}
Total PoW hashrate $\mathcal{H}$ is independent of the operating mode.
\end{proposition}
\begin{proof}[Argument]
$\mathcal{H} = N_{\mathrm{cores}} \times \mathrm{throughput\_per\_core}$. Each core's throughput is 1~hash per $\mathrm{pipeline\_depth}$ cycles (fully pipelined), regardless of whether the input is a STARK Merkle pair or a random nonce. Input MUX adds zero latency (combinational logic). Therefore $\mathcal{H}$ is constant across Symbiotic, Pure PoW, and any mixed state.
\end{proof}

\subsection{Difficulty Independence}

$U$ is determined by ZK demand and width ratio, not by PoW difficulty.

\begin{table}[h]
\centering
\begin{tabular}{@{}lcl@{}}
\toprule
Condition & $U$ & Rationale \\
\midrule
Stwo Prover active, any difficulty & $\approx 67\%$ & ZK proof, minus width overhead \\
No ZK demand, any difficulty & $0\%$ & Pure PoW = security only \\
\bottomrule
\end{tabular}
\caption{Usefulness is independent of difficulty.}
\label{tab:difficulty}
\end{table}

\subsection{Complementary Bottleneck Structure}
\label{sec:bottleneck}

The simultaneous execution of PoW and STARK is possible because they bottleneck on different resources:

\begin{table}[h]
\centering
\begin{tabular}{@{}lcccc@{}}
\toprule
Resource & PoW & STARK & Combined \\
\midrule
Poseidon2 cores & \textbf{100\%} (compute-bound) & Low (SRAM-starved) & ${\sim}$\textbf{100\%} \\
NTT unit & 0\% & \textbf{100\%} & \textbf{100\%} \\
SRAM bandwidth & 0\% (registers only) & \textbf{100\%} (memory-bound) & \textbf{100\%} \\
\bottomrule
\end{tabular}
\caption{Complementary bottleneck structure.}
\label{tab:bottleneck}
\end{table}

Under 200~GB/s SRAM bandwidth, the STARK allocation is $f_{\mathrm{sym}} \approx 10\%$ of Poseidon2 cycles, yielding $U_{\mathrm{avg}} = f_{\mathrm{sym}} \times U \approx 6.7\%$ time-averaged usefulness (see \S\ref{sec:sram} for derivation).

\textbf{Width-24 efficiency.} Width-24 compression uses 1~permutation per Merkle hash versus Width-16 sponge's 2~permutations. This halves STARK's Poseidon2 cycle consumption, freeing more cycles for PoW.

% ============================================================
\section{Pareto Analysis}
\label{sec:pareto}

\subsection{Competing Designs}

Four designs compared under identical die area and power budget:

\begin{table}[h]
\centering
\small
\begin{tabular}{@{}llcccc@{}}
\toprule
Design & Die allocation & Hashrate & ZK & $U$ & Mine? \\
\midrule
Pure PoW & 95\% Pos2, 5\% ctrl & ${\sim}1.9\,\mathcal{H}$ & 0 & 0\% & Yes \\
Pure Stwo & 20\% Pos2, 40\% NTT, 35\% SRAM & 0 & $Z_{\max}$ & 100\% & No \\
\textbf{ZK-SPoW} & \textbf{50\% Pos2, 25\% NTT, 20\% SRAM} & $\mathcal{H}$ & $Z$ & $\mathbf{{\approx}67\%}$ & \textbf{Yes} \\
ZK-SPoW+HBM & 50\% Pos2, 25\% NTT, 20\% HBM & $\mathcal{H}$ & $Z_{\mathrm{hbm}}$ & ${\approx}67\%$ & Yes \\
\bottomrule
\end{tabular}
\caption{Pareto comparison of competing designs.}
\label{tab:pareto}
\end{table}

Pure PoW achieves ${\sim}1.9\times$ hashrate on a die-area basis (95\%/50\% Poseidon2 allocation) but produces no ZK proofs ($U = 0\%$). On a hashes-per-watt basis, the gap narrows to ${\sim}1.1$--$1.2\times$ because idle NTT and SRAM contribute static leakage (${\sim}10$--$20\%$ of dynamic power). Pure Stwo uses standard Width-16 cores ($U = 100\%$) but cannot mine. ZK-SPoW achieves $U \approx 67\%$ and mining capability---the 33\% usefulness gap is the cost of PoW integration via width extension.

\subsection{Economic Dominance}

Difficulty adjusts to total network hashrate. When all $N$ miners use the same design, per-ASIC mining revenue is $B/N$ regardless of absolute hashrate. The differentiator is ZK revenue:
\[
\text{ZK-SPoW revenue} = B/N + Z \cdot F \;>\; B/N = \text{Pure PoW revenue} \quad (\text{for any } ZF > 0)
\]

Pure PoW's ${\sim}1.1$--$1.2\times$ power-efficiency advantage yields at most ${\sim}10$--$20\%$ more mining revenue per watt in a mixed network. Once ZK fee income $Z \cdot F$ exceeds this margin, ZK-SPoW dominates.

\textbf{PoW security without ZK demand.} ZK-SPoW does not condition PoW security on ZK demand. When $Z \cdot F = 0$ (no ZK market), the ASIC operates as a conventional PoW miner with a hash/watt disadvantage due to the die area overhead (\S\ref{sec:design-c}). Difficulty adjustment absorbs this: in a homogeneous ZK-SPoW network, per-ASIC mining revenue is identical to a homogeneous Pure PoW network. The die overhead is the cost of optionality---it purchases the ability to capture ZK revenue when the market emerges, without sacrificing PoW security in the interim.

% ============================================================
\section{Security Considerations}
\label{sec:security}

\subsection{Poseidon2 Cryptographic Properties}

Poseidon2~\cite{poseidon2} provides 128-bit security in sponge mode with capacity $c = 8$ M31 elements (248 bits). In compression function mode (ZK-SPoW), security relies on collision resistance and preimage resistance of the permutation---well-established properties within the Poseidon2 framework~\cite{poseidon2}. StarkWare has adopted Poseidon2 for production use in Starknet, representing significant implicit endorsement of its security.

\textbf{Note:} All security claims in this paper assume final production round constants. The current Stwo implementation uses placeholder values (see \S\ref{sec:open}).

\subsection{Single Primitive Dependency}

\begin{table}[h]
\centering
\begin{tabular}{@{}lll@{}}
\toprule
Component & Current Kaspa & Proposed \\
\midrule
PoW & kHeavyHash (cSHAKE256) & Poseidon2 \\
STARK & Poseidon2 & Poseidon2 \\
Independence & PoW $\neq$ STARK & PoW = STARK \\
\bottomrule
\end{tabular}
\caption{Single primitive dependency.}
\label{tab:dependency}
\end{table}

\textbf{Risk:} A cryptographic break in Poseidon2 compromises both PoW security and STARK validity simultaneously. This concentration risk is shared with the broader Poseidon2 ecosystem (notably Starknet).

\subsection{Width-24 Security}
\label{sec:width24sec}

\textbf{Collision resistance (STARK binding).} STARK Merkle tree integrity requires collision resistance of the Width-24 compression function. With 248-bit output (8 M31 elements), the birthday bound is $2^{124}$, providing 124-bit collision security.

\textbf{STARK soundness.} The $\mathit{header\_digest}$ acts as a fixed salt in each Merkle hash: it is determined by the block header before proof generation begins and cannot be chosen adaptively by the prover. STARK soundness therefore reduces to collision resistance of the Width-24 compression function with a fixed third input---a strictly easier assumption than collision resistance under adversarially chosen inputs.

\textbf{Preimage resistance (PoW security).} PoW requires only preimage resistance of the 248-bit output---trivially satisfied by 30 rounds of Poseidon2 (8 external + 22 internal).

\textbf{$R_p$ for Width-24.} The internal round count increases from $R_p = 14$ (Width-16) to $R_p = 22$ (Width-24) for 128-bit security at $D = 5$ over M31. This is confirmed by Plonky3's verified round number computation~\cite{plonky3}, which applies the security constraints from \cite{poseidon,poseidon2} plus the algebraic attack bound from Khovratovich et al.\ (ePrint 2023/537), with a security margin of $R_f \mathrel{{+}{=}} 2$, $R_p \times 1.075$. The binding constraint is statistical ($R_f \geq 6$). Total rounds: 30 ($8 + 22$) vs 22 ($8 + 14$) for Width-16. Despite 51\% more S-box operations per permutation (214 vs 142), the per-ticket cost \emph{decreases} by 25\% ($214/2 = 107$ vs $142/1 = 142$ S-boxes per PoW ticket).

\subsection{PoW Hash Distribution}
\label{sec:pow-dist}

Both $\mathit{pow\_hash}_1 = S[8..15]$ and $\mathit{pow\_hash}_2 = S[16..23]$ are outputs of the same Poseidon2 permutation. Security relies on the permutation's PRP properties: given a random-looking input, all output elements should be indistinguishable from random.

\textbf{Dual-ticket mining advantage:} Under the PRP assumption on Poseidon2 (see \S\ref{sec:open} item~8 for correlation analysis), the two tickets are approximately independent. With two 248-bit tickets per permutation:
\[
P(\text{valid}) = 1 - (1 - T/2^{248})^2 \approx 2T/2^{248} \quad \text{for small } T/2^{248}
\]
This yields $+100\%$ improvement in expected block-finding rate per permutation (equivalent to $+67\%$ per unit die area vs Design~B single-ticket, after accounting for the increased core area of Width-24).

\subsection{Quantum Resistance}

Poseidon2's security against quantum adversaries:
\begin{itemize}
\item Grover's algorithm halves the effective hash bits: $248/2 = 124$-bit quantum security
\item Comparable to SHA-256 under quantum attack ($256/2 = 128$ bits)
\item kHeavyHash: $256/2 = 128$-bit quantum security
\item \textbf{Delta:} $-8$ bits classical (248 vs 256) / $-4$ bits quantum (124 vs 128). Both values remain well above the 100-bit security floor considered acceptable for PoW functions.
\end{itemize}

% ============================================================
\section{Comparison with Prior Work}
\label{sec:comparison}

\subsection{Design Evolution}

Five architectures were explored before converging on ZK-SPoW:

\begin{table}[h]
\centering
\small
\begin{tabular}{@{}clll@{}}
\toprule
\# & Architecture & Verdict & Primary rejection reason \\
\midrule
1 & Core Division ($\alpha = 1\%$) & Practical & $U = 1\%$, cannot claim symbiosis \\
2 & Rate-4 Poseidon & Theoretical & FRI cascade cost, timing misalignment \\
3 & ZK-Symbiotic (HW multithread) & Best engineering & Not PoUW by~\cite{ball2017} \\
4 & MatMul PoUW~\cite{komargodski2025} & Domain-specific & $O(n^3)$ verification, 100~BPS \\
5 & Direction~C (Pure ZK PoUW) & Unsolved & Fiat-Shamir cascade barrier \\
\bottomrule
\end{tabular}
\caption{Design evolution.}
\label{tab:evolution}
\end{table}

The final design synthesizes insights from Architecture~\#2 (dual-use Poseidon outputs) and Architecture~\#3 (hardware multithreading with low-cost context switch), while avoiding their individual weaknesses.

\subsection{Key Design Decisions}

\begin{table}[h]
\centering
\small
\begin{tabular}{@{}lll@{}}
\toprule
Decision & Choice & Rationale \\
\midrule
STARK proof in block? & \textbf{No} (Option~C) & Eliminates +3--5~MB/s at 100~BPS \\
Hash function & \textbf{Poseidon2} & Stwo-Kaspa compatibility \\
Field & \textbf{M31} & Smallest multiplier, highest density \\
Permutation width & \textbf{24} & 1~perm/hash + dual tickets \\
Operating mode & \textbf{Compression} & 1~perm/hash; recommended by~\cite{poseidon2} \\
PoW tickets per hash & \textbf{2} & $S[8..15]$ and $S[16..23]$ \\
PoW hash size & \textbf{248 bits} & 8~M31 elements \\
STARK enforcement & \textbf{None} & Market-driven ZK adoption \\
Verifier & \textbf{Stwo-Kaspa} & Width-24 compression \\
\bottomrule
\end{tabular}
\caption{Key design decisions.}
\label{tab:decisions}
\end{table}

\subsection{Relationship to Ball et al.}

Ball et al.~\cite{ball2017} formalize PoUW in the direction \textbf{PoW $\to$ useful output}. ZK-SPoW operates in the inverse direction: \textbf{useful computation $\to$ PoW output}.

\begin{table}[h]
\centering
\small
\begin{tabular}{@{}lll@{}}
\toprule
Ball et al.\ criterion & PoW $\to$ useful (their framework) & Useful $\to$ PoW (ZK-SPoW) \\
\midrule
Produces useful output & Partial: PoW-fill = security-only & \textbf{Yes}: every Symbiotic perm \\
Verifier confirms & Not enforced (Option~C) & STARK proofs publicly checkable \\
Bound to PoW & Not enforced & \textbf{Inherent}: same permutation \\
\bottomrule
\end{tabular}
\caption{Relationship to Ball et al.~\cite{ball2017}.}
\label{tab:ball}
\end{table}

Under their original framework (PoW $\to$ useful), ZK-SPoW satisfies 0 of 3 criteria strictly. Under the inverted framing (useful $\to$ PoW), the STARK computation drives the permutation, PoW tickets are a cryptographically bound byproduct, and the proof is publicly verifiable.

Ofelimos~\cite{ofelimos} is the closest prior work. Komargodski et al.~\cite{komargodski2025,baron2025} explore PoUW via matrix multiplication and external utility functions. ZK-SPoW differs from both: (1)~the useful computation is market-driven rather than protocol-mandated (Option~C), and (2)~PoW tickets emerge as a byproduct of STARK hashing rather than through a separate verification mechanism.

% ============================================================
\section{Open Questions}
\label{sec:open}

\begin{enumerate}
\item \textbf{Stwo production parameters.} The baseline parameters (Width~16, Rate~8, Capacity~8, $R_f = 8$, $R_p = 14$) are confirmed from source code~\cite{stwo}. However, round constants are explicit placeholders (\texttt{1234}; see TODO in source). Final production constants are required before security analysis can be completed.

\item \textbf{$R_p$ for Width-24 (resolved).} $R_p = 22$ confirmed via Plonky3~\cite{plonky3}. See \S\ref{sec:width24sec}.

\item \textbf{Stwo-Kaspa verifier.} Width-24 Poseidon2 compression is a different cryptographic function from Width-16 sponge. A Kaspa-specific verifier is required. Plonky3~\cite{plonky3} already provides a production Width-24 Poseidon2 implementation over M31 with verified parameters. The remaining requirements are: (a)~round constant finalization, (b)~integration with Stwo's proof system, (c)~independent security certification.

\item \textbf{Hard fork governance.} Transitioning from kHeavyHash to Poseidon2 renders existing kHeavyHash ASICs obsolete and requires community consensus.

\item \textbf{Mining pool protocol.} The 64-byte nonce (vs current 8-byte) requires updates to the stratum protocol. Stratum~V2 may accommodate this natively.

\item \textbf{ZK market maturity.} The economic advantage of ZK-SPoW over Pure PoW depends on sufficient ZK proof demand.

\item \textbf{Complementary bottleneck validation.} The claim that PoW (compute-bound) and STARK (memory-bound) can run simultaneously at full throughput requires hardware-level validation.

\item \textbf{Dual-ticket independence.} The two PoW tickets are outputs of the same permutation and thus deterministically linked. While each is individually pseudorandom under PRP assumptions, the correlation should be formally analyzed.

\item \textbf{Trace grinding.} In Symbiotic mode, a miner with freedom in trace generation could selectively construct STARK Merkle trees that increase PoW ticket success probability. The grinding advantage is bounded by the miner's degrees of freedom relative to the total Merkle tree size (${\sim}10^6$--$10^7$ nodes), but requires quantitative analysis.
\end{enumerate}

% ============================================================
\appendix

\section{ASIC Architecture Details}
\label{app:asic}

\subsection{ZK-Symbiotic ASIC Block Diagram}

\begin{Verbatim}[fontsize=\scriptsize]
+-- ZK-SPoW ASIC (7nm, ~200W) -----------------------------------------+
|                                                                        |
|  +-- Poseidon2 Core Array (50% die) --------------------------------+ |
|  |                                                                    | |
|  |  [Core 0] [Core 1] [Core 2] ... [Core N-1]                        | |
|  |  Each core: Width-24 Poseidon2 pipeline (M31)                     | |
|  |  Mode: Symbiotic (STARK Merkle) or PoW (nonce), per-cycle MUX    | |
|  |                                                                    | |
|  |  Per-Core:  [Input MUX] -> [Poseidon2 Pipeline R1..R30] ->        | |
|  |             [Output Router: SRAM write / target comparator]        | |
|  +--------------------------------------------------------------------+ |
|                                                                        |
|  +-- NTT Butterfly Unit (25% die) ----------------------------------+ |
|  |  M31 multiply-accumulate array                                     | |
|  |  STARK: polynomial LDE + FRI folding                               | |
|  +--------------------------------------------------------------------+ |
|                                                                        |
|  +-- SRAM (20% die) ------------------------------------------------+ |
|  |  32 MB on-chip, ~200 GB/s bandwidth                                | |
|  |  STARK: eval values, Merkle tree nodes, FRI intermediate data      | |
|  +--------------------------------------------------------------------+ |
|                                                                        |
|  +-- Control & I/O (5% die) ----------------------------------------+ |
|  |  PoW controller, STARK controller, scheduler, network interface    | |
|  +--------------------------------------------------------------------+ |
+------------------------------------------------------------------------+
\end{Verbatim}

\subsection{Poseidon2 Core Circuit (M31)}

\subsubsection{M31 Field Arithmetic}

Mersenne property: $2^{31} \equiv 1 \pmod{p}$, so the upper bits fold directly into the lower bits with a single addition.

\begin{table}[h]
\centering
\begin{tabular}{@{}lll@{}}
\toprule
Metric & M31 & Goldilocks ($2^{64} - 2^{32} + 1$) \\
\midrule
Multiplier width & $31 \times 31 \to 62$ bit & $64 \times 64 \to 128$ bit \\
Reduction & 1 addition & shift + sub + add \\
Gate count & ${\sim}1{,}000$ & ${\sim}3{,}500$ \\
Latency & 1 cycle & 2--3 cycles \\
Area ratio & $\mathbf{1\times}$ & $3.5\times$ \\
\bottomrule
\end{tabular}
\caption{M31 vs Goldilocks field arithmetic.}
\label{tab:m31-gold}
\end{table}

\subsubsection{S-box: $x^5 \bmod p$}

\begin{Verbatim}[fontsize=\small]
x --> [MUL] --> x^2
       [MUL] --> x^4 = (x^2)^2
       [MUL] --> x^5 = x^4 * x

Critical path: 3 sequential multiplications
Gate count (M31): 3 x 1,000 = ~3,000 gates
\end{Verbatim}

\subsubsection{MDS Matrix (Poseidon2)}

\textbf{External rounds} use a block-circulant structure based on the Stwo/HorizenLabs M4:
\[
M_4 = \begin{pmatrix} 5 & 7 & 1 & 3 \\ 4 & 6 & 1 & 1 \\ 1 & 3 & 5 & 7 \\ 1 & 1 & 4 & 6 \end{pmatrix}
\]
Width~24 = 6 groups of 4 $\to$ 6 M4 applications $\to$ \textbf{shift+add only} in external MDS.

\textbf{Internal rounds} use sparse MDS: $M_I = \mathbf{1}\mathbf{1}^\top + \mathrm{diag}(V)$, where $V = [-2, 1, 2, 4, \ldots, 2^{22}]$ (Plonky3 production values~\cite{plonky3}).

\subsubsection{Full Round vs Partial Round}

\begin{table}[h]
\centering
\begin{tabular}{@{}lll@{}}
\toprule
Component & External round ($\times 8$) & Internal round ($\times 22$) \\
\midrule
S-box & $24 \times 3$K $= 72$K gates & $1 \times 3$K $= 3$K gates \\
MDS & M4 blocks (${\sim}12$K gates) & diag $+ \mathbf{1}\mathbf{1}^\top$ (${\sim}24$K gates) \\
Round constants & $24 \times 100 = 2.4$K & $2.4$K \\
\textbf{Subtotal} & $\mathbf{{\sim}86}$\textbf{K gates} & $\mathbf{{\sim}29}$\textbf{K gates} \\
\bottomrule
\end{tabular}
\caption{Per-round gate counts.}
\label{tab:rounds}
\end{table}

\textbf{Total core (pipelined):}
\[
8 \times 86\text{K} + 22 \times 29\text{K} = 688\text{K} + 638\text{K} \approx 1{,}326\text{K gates (Width 24)}
\]
Standard Width~16: $8 \times 58\text{K} + 14 \times 21\text{K} = 464\text{K} + 294\text{K} \approx 758\text{K gates}$. Overhead: $+75\%$ core logic.

\subsection{Pipeline Design Options}

\begin{table}[h]
\centering
\begin{tabular}{@{}lcccc@{}}
\toprule
Pipeline style & Gates/core & Cores & Perm/sec/core & Effective hash/sec \\
\midrule
Folded ($\times 1$) & 86K & 348 & 33M & \textbf{23G} \\
5-stage & 300K & 100 & 167M & \textbf{33G} \\
10-stage & 550K & 54 & 333M & \textbf{36G} \\
Full ($\times 30$) & 1.4M & 21 & 1G & \textbf{42G} \\
\bottomrule
\end{tabular}
\caption{Die-level comparison (60M gate die, 50\% to Poseidon2, 2 tickets/perm).}
\label{tab:pipeline}
\end{table}

\subsection{Header Pre-absorption}

Block header $H$ is variable-length. Hashing it every nonce attempt is wasteful.

\textbf{Optimization:} pre-absorb header into Poseidon2 sponge state.
\begin{Verbatim}[fontsize=\small]
On header change (~100 times/sec at 100 BPS):
  h_H = PoseidonSponge(parent_hashes || tx_merkle_root || timestamp)
  -> 8 M31 elements, stored in header_state register

Per nonce attempt (compression function mode, width 24):
  S[0..7]   <- v1   (nonce part 1)
  S[8..15]  <- v2   (nonce part 2)
  S[16..23] <- h_H  (from register, constant)
  -> 1 Poseidon2 permutation (30 rounds)
  -> output S[8..15] and S[16..23] compared against target (2 tickets)
\end{Verbatim}

\textbf{Cost per nonce:} exactly 1 Poseidon2 permutation. Header pre-hash is amortized across ${\sim}10$M nonce attempts per header change.

\subsection{SRAM Bandwidth and Throughput Allocation}
\label{sec:sram}

\subsubsection{STARK Memory Access Pattern}

Each Poseidon2 Merkle hash requires:
\begin{Verbatim}[fontsize=\small]
Read:  left_child  = 8 x 4 bytes = 32 bytes
Read:  right_child = 8 x 4 bytes = 32 bytes
Write: parent_node = 8 x 4 bytes = 32 bytes
Total: 96 bytes per hash
\end{Verbatim}

\subsubsection{Throughput Calculation}
\begin{align*}
\text{SRAM bandwidth} &\approx 200~\text{GB/s} \\
\text{Bytes per STARK hash} &= 96 \\
\text{STARK hash throughput} &= 200\text{G}/96 \approx 2.08\text{G hash/sec} \\
\text{Total Poseidon2 throughput} &\approx 21\text{G perm/sec (21 cores @ 1\,GHz)} \\
\text{Effective PoW hashrate} &\approx 42\text{G hash/sec (2 tickets/perm)} \\
\text{STARK allocation: } f_{\mathrm{sym}} &= 2.08/21 \approx 9.9\%
\end{align*}

\subsubsection{Interpretation}

\begin{table}[h]
\centering
\begin{tabular}{@{}lll@{}}
\toprule
Metric & Value & Note \\
\midrule
Hardware STARK fraction ($f$) & ${\sim}10\%$ & SRAM-bandwidth limited \\
Hardware PoW fraction & ${\sim}90\%$ & Fills idle Poseidon2 cycles \\
$U$ (usefulness) & $\approx 67\%$ & $t_0/t = 16/24$ \\
STARK proofs/sec & ${\sim}260$ & $2.08\text{G}/8\text{M hashes per proof}$ \\
PoW hashrate & ${\sim}42$G effective & $21\text{G perm/sec} \times 2$ tickets \\
$U_{\mathrm{avg}}$ & $\approx 6.7\%$ & $f \times U = 0.10 \times 0.67$ \\
\bottomrule
\end{tabular}
\caption{Throughput allocation summary.}
\label{tab:throughput}
\end{table}

\textbf{Time-averaged usefulness.} $U_{\mathrm{avg}} = f_{\mathrm{sym}} \times U \approx 0.10 \times 0.67 \approx 6.7\%$ under 200~GB/s SRAM bandwidth with the STARK prover continuously active. This means 6.7\% of all Poseidon2 cycles advance ZK proofs; the remaining 93.3\% provide PoW security only. $U_{\mathrm{avg}}$ scales with memory bandwidth.

\subsubsection{Increasing STARK Throughput}

\begin{table}[h]
\centering
\begin{tabular}{@{}lcccc@{}}
\toprule
Memory technology & Bandwidth & $f$ & $U_{\mathrm{avg}}$ ($f \times 67\%$) & Proofs/sec \\
\midrule
SRAM 32\,MB & 200\,GB/s & ${\sim}10\%$ & ${\sim}6.7\%$ & ${\sim}260$ \\
SRAM 64\,MB & 400\,GB/s & ${\sim}20\%$ & ${\sim}13\%$ & ${\sim}520$ \\
HBM3 8\,GB & 1.2\,TB/s & ${\sim}60\%$ & ${\sim}40\%$ & ${\sim}1{,}560$ \\
HBM3E 16\,GB & 2.4\,TB/s & ${\sim}100\%$ & ${\sim}67\%$ & ${\sim}3{,}120$ \\
\bottomrule
\end{tabular}
\caption{$U_{\mathrm{avg}}$ scaling with memory bandwidth.}
\label{tab:memory-scaling}
\end{table}

\subsection{Die Area: kHeavyHash vs Poseidon2-PoW}

\subsubsection{kHeavyHash Core}
\begin{Verbatim}[fontsize=\small]
cSHAKE256 hash (x2):        ~80K gates (2x Keccak-f[1600])
64x64 nibble matrix mul:    ~65K gates
Control:                      ~5K gates
Total:                      ~150K gates per core
Throughput:                 ~1G hashes/sec per core @ 1GHz
\end{Verbatim}

\subsubsection{Poseidon2-PoW Core (M31, Width 24, Full Pipeline)}
\begin{Verbatim}[fontsize=\small]
S-box circuits:             ~642K gates
  External: 24 x 3K x 8 rounds = 576K
  Internal:  1 x 3K x 22 rounds = 66K
MDS circuits:               ~624K gates
  External: 6 M4 blocks x ~2K x 8 rounds = 96K (shift+add only)
  Internal: 24 x 1K x 22 rounds = 528K
Round constant storage:      ~55K gates (214 constants x 31 bits)
Pipeline registers:          ~108K gates (24 x 31 bits x 29 stages)
Input MUX + output router:   ~1K gates
PoW controller:              ~2K gates
Total:                       ~1.4M gates per core
Throughput:                  ~1G perm/sec -> 2G effective hash/sec @ 1GHz
\end{Verbatim}

\subsubsection{Chip-Level Comparison}

\begin{table}[h]
\centering
\small
\begin{tabular}{@{}lll@{}}
\toprule
Metric & kHeavyHash ASIC & Poseidon2-PoW (Width 24) \\
\midrule
Core area & ${\sim}150$K gates & ${\sim}1.4$M gates \\
Cores (60M gate die) & ${\sim}380$ (95\% utilized) & ${\sim}21$ (50\% allocated) \\
Throughput per core & ${\sim}1$G/s & ${\sim}1$G perm/s $\to$ 2G eff/s \\
Total chip hashrate & ${\sim}380$G/s & ${\sim}42$G/s effective \\
ZK proof capability & None & ${\sim}260$ proofs/sec \\
\bottomrule
\end{tabular}
\caption{Chip-level comparison: kHeavyHash vs Poseidon2-PoW.}
\label{tab:chip}
\end{table}

Poseidon2 has ${\sim}9\times$ lower PoW hashrate per die than kHeavyHash. \textbf{This is absorbed by difficulty adjustment}---all miners use the same hash function, so per-miner revenue is determined by hashrate share, not absolute hashrate.

\subsection{M31 vs Goldilocks ASIC Comparison}

\begin{table}[h]
\centering
\begin{tabular}{@{}lll@{}}
\toprule
Metric & Goldilocks ($2^{64}-2^{32}+1$) & M31 ($2^{31}-1$) \\
\midrule
Element size & 64 bits & 31 bits \\
Multiplier gates & ${\sim}3{,}500$ & ${\sim}1{,}000$ \\
Multiplier latency & 2--3 cycles & 1 cycle \\
Poseidon2 width (ext.) & 13 (rate 9, cap 4) & 24 (compression) \\
Hash output & $4 \times 64 = 256$ bits & $8 \times 31 = 248$ bits \\
Cores per die (30M gates) & ${\sim}23$ & ${\sim}21$ \\
STARK ecosystem & Plonky2/Plonky3 & \textbf{Stwo (potential Kaspa choice)} \\
\bottomrule
\end{tabular}
\caption{M31 vs Goldilocks ASIC comparison.}
\label{tab:m31-vs-gold}
\end{table}

\textbf{M31 is the natural choice} if Kaspa adopts Stwo. The smaller multiplier (1/3.5 area) enables higher core density and hashrate per die, while matching Stwo's field arithmetic exactly.

% ============================================================
\begin{thebibliography}{10}

\bibitem{ball2017}
M.~Ball, A.~Rosen, M.~Sabin, and P.~N.~Vasudevan,
``Proofs of Useful Work,''
\emph{IACR Cryptology ePrint Archive}, 2017/203, 2017.
\url{https://eprint.iacr.org/2017/203}

\bibitem{poseidon}
L.~Grassi, D.~Khovratovich, C.~Rechberger, A.~Roy, and M.~Schofnegger,
``Poseidon: A New Hash Function for Zero-Knowledge Proof Systems,''
in \emph{USENIX Security Symposium}, 2021.
\url{https://eprint.iacr.org/2019/458}

\bibitem{poseidon2}
L.~Grassi, D.~Khovratovich, and M.~Schofnegger,
``Poseidon2: A Faster Version of the Poseidon Hash Function,''
\emph{IACR Cryptology ePrint Archive}, 2023/323, 2023.
\url{https://eprint.iacr.org/2023/323}

\bibitem{stwo}
StarkWare,
``Stwo: A STARK Prover.''
\url{https://github.com/starkware-libs/stwo}

\bibitem{dagknight}
Y.~Sompolinsky and M.~Sutton,
``The DAG KNIGHT Protocol: A Parameterless Generalization of Nakamoto Consensus,''
\emph{IACR Cryptology ePrint Archive}, 2022/1494, 2022.
\url{https://eprint.iacr.org/2022/1494}

\bibitem{kaspa}
Kaspa,
``kHeavyHash Specification.''
\url{https://github.com/kaspanet/rusty-kaspa}

\bibitem{ofelimos}
M.~Fitzi, A.~Kiayias, G.~Panagiotakos, and A.~Russell,
``Ofelimos: Combinatorial Optimization via Proof-of-Useful-Work,''
in \emph{Crypto 2022}.
\url{https://eprint.iacr.org/2021/1379}

\bibitem{komargodski2025}
I.~Komargodski and O.~Weinstein,
``Proofs of Useful Work from Arbitrary Matrix Multiplication,''
\emph{IACR Cryptology ePrint Archive}, 2025/685, 2025.
\url{https://eprint.iacr.org/2025/685}

\bibitem{baron2025}
Y.~Bar-On, I.~Komargodski, and O.~Weinstein,
``Proof of Work With External Utilities,''
arXiv:2505.21685, 2025.
\url{https://arxiv.org/abs/2505.21685}

\bibitem{plonky3}
Plonky3,
``A Toolkit for Polynomial IOPs,''
\texttt{poseidon2/src/round\_numbers.rs}, \texttt{mersenne-31/src/poseidon2.rs}.
\url{https://github.com/Plonky3/Plonky3} (accessed 2026-02-16).

\end{thebibliography}

\end{document}
